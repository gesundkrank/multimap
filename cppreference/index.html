<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="1:n key-value store for C++ and Java">
    <meta name="author" content="Martin Trenkmann">
    <link rel="icon" href="../favicon.ico">
    <title>Multimap</title>
    
    <!-- jQuery -->
    <script src="http://code.jquery.com/jquery-1.11.3.min.js"></script>
    
    <!-- Bootstrap -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    
    <!-- highlight.js -->
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/googlecode.min.css">
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <!-- Fonts -->
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Faster+One">
    <!--
    <link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
    Firefox Console: The stylesheet https://code.cdn.mozilla.net/fonts/fira.css
    was not loaded because its MIME type, "application/octet-stream", is not "text/css".
    -->
    <link rel="stylesheet" href="../fonts/fira.css">
    
    <!-- Customized Bootstrap style -->
    <link rel="stylesheet" href="../bootstrap-multimap.css">
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script>
      function nbsp(n) {
        for (var i = 0; i < n; ++i) {
          document.write("&nbsp;");
        }
      }
    </script>
  </head>
  
  <body data-spy="scroll" data-target="#multimap-sidebar" data-offset="50">
    <div id="main">
      <nav class="navbar navbar-inverse navbar-static-top">
        <div class="container">
          <img alt="Logo" id="multimap-logo" src="../logo.png">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#multimap-navbar-collapse" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <span class="navbar-brand">Multimap</span>
        </div>
        <div class="container">
          <div class="collapse navbar-collapse" id="multimap-navbar-collapse">
            <ul class="nav navbar-nav">
              
                
                  <li >
                    <a href="..">Home</a>
                  </li>
                
              
                
                  <li >
                    <a href="../overview/">Overview</a>
                  </li>
                
              
                
                  <li class="dropdown ">
                    <a href="#">Tutorials <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li class="dropdown-header">C++</li>
                          
                            <li >
                              <a href="../cppbasics/">Basics</a>
                            </li>
                          
                        
                      
                        
                          <li class="dropdown-header">Java</li>
                          
                            <li >
                              <a href="../javabasics/">Basics</a>
                            </li>
                          
                        
                      
                    </ul>
                  </li>
                
              
                
                  <li class="dropdown  active ">
                    <a href="#">Reference <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li  class="active" >
                            <a href="./">C++ Reference</a>
                          </li>
                        
                      
                        
                          <li >
                            <a href="../javareference/">Java Reference</a>
                          </li>
                        
                      
                    </ul>
                  </li>
                
              
                
                  <li class="dropdown ">
                    <a href="#">Installation <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                      
                        
                          <li >
                            <a href="../cppinstallation/">for C++ Developers</a>
                          </li>
                        
                      
                        
                          <li >
                            <a href="../javainstallation/">for Java Developers</a>
                          </li>
                        
                      
                    </ul>
                  </li>
                
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">GitHub <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  <li><a href="https://github.com/mtrenkmann/multimap" target="_blank">View on GitHub</a></li>
                  <li><a href="https://github.com/mtrenkmann/multimap/issues" target="_blank">Create an Issue</a></li>
                  <li><a href="https://github.com/mtrenkmann/multimap/subscription" target="_blank">Watch this Project</a></li>
                </ul>
              </li>
            </ul>
          </div>
        </div>
      </nav>
      
      
        <div class="container">
          <div class="row">
            
              <div class="col-md-9" role="main">
                <h2 id="byteshpp">Bytes.hpp</h2>
<pre><code class="cpp">#include &lt;multimap/Bytes.hpp&gt;
namespace multimap
</code></pre>

<h3 id="class-bytes">class Bytes</h3>
<p>This class is a thin wrapper for raw binary data. It just holds a pointer to data together with its size (number of bytes). It is used to represent keys and values that are put into or gotten from a map. An object of this class never deep copies the data it is constructed from, nor does it take any ownership of the data. It is really just a helper for providing a generic interface.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Bytes()</code>
   <div>Creates an empty byte array. <a href="#bytes-bytes">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Bytes(const char * cstr)</code>
   <div>Creates a byte array from a null-terminated C-string. <a href="#bytes-bytes-cstr">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Bytes(const std::string & str)</code>
   <div>Creates a byte array from a standard string. <a href="#bytes-bytes-str">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Bytes(const void * data, size_t size)</code>
   <div>Creates a byte array from arbitrary data. <a href="#bytes-bytes-data-size">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>const char *</code></td>
  <td>
   <code>data() const</code>
   <div>Returns a read-only pointer to the wrapped data.<div>
  </td>
 </tr>
 <tr>
  <td><code>size_t</code></td>
  <td>
   <code>size() const</code>
   <div>Returns the number of bytes wrapped.<div>
  </td>
 </tr>
 <tr>
  <td><code>const char *</code></td>
  <td>
   <code>begin() const</code>
   <div>Returns a read-only pointer to the beginning of the wrapped data.<div>
  </td>
 </tr>
 <tr>
  <td><code>const char *</code></td>
  <td>
   <code>end() const</code>
   <div>Returns a past-the-end pointer to the wrapped data.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>empty() const</code>
   <div>Tells whether the byte array is empty. <a href="#bytes-empty">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>clear()</code>
   <div>Let this byte array point to an empty array. <a href="#bytes-clear">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>std::string</code></td>
  <td>
   <code>toString() const</code>
   <div>Returns a string which contains a copy of the wrapped data. <a href="#bytes-tostring">more...</a><div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Non-member functions</th>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator==(const Bytes & lhs, const Bytes & rhs)</code>
   <div>Compares two byte arrays for equality. <a href="#operator-eq">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator!=(const Bytes & lhs, const Bytes & rhs)</code>
   <div>Returns the inverse of the previous function.<div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Helper classes</th>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>std::hash&lt;Bytes&gt;</code>
   <div>Hash support for class Bytes.<div>
  </td>
 </tr>
</tbody>
</table>

<div class="reference-more">
 <h4 id="bytes-bytes"><code>Bytes::Bytes()</code></h4>
 <p>Creates an empty byte array.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() != nullptr</code></li>
  <li><code>size() == 0</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-bytes-cstr"><code>Bytes::Bytes(const char * cstr)</code></h4>
 <p>Creates a byte array from a null-terminated C-string. This constructor allows implicit conversion.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() == cstr</code></li>
  <li><code>size() == std::strlen(cstr)</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-bytes-str"><code>Bytes::Bytes(const std::string & str)</code></h4>
 <p>Creates a byte array from a standard string. This constructor allows implicit conversion.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() == str.data()</code></li>
  <li><code>size() == str.size()</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-bytes-data-size"><code>Bytes::Bytes(const void * data, size_t size)</code></h4>
 <p>Creates a byte array from arbitrary data.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() == data</code></li>
  <li><code>size() == size</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-empty"><code>bool Bytes::empty() const</code></h4>
 <p>Tells whether the byte array is empty. Returns <code>true</code> if the number of bytes is zero, <code>false</code> otherwise.</p>
</div>

<div class="reference-more">
 <h4 id="bytes-clear"><code>void Bytes::clear()</code></h4>
 <p>Let this byte array point to an empty array.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() != nullptr</code></li>
  <li><code>size() == 0</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="bytes-tostring"><code>std::string toString() const</code></h4>
 <p>Returns a string which contains a copy of the wrapped data. <code>std::string</code> is used as a convenient byte buffer and may contain bytes that are not printable or even null-bytes.</p>
 <p><span class="ensures" /></p>
 <ul>
  <li><code>data() != return_value.data()</code></li>
  <li><code>size() == return_value.size()</code></li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="operator-eq"><code>bool operator==(const Bytes & lhs, const Bytes & rhs)</code></h4>
 <p>Compares two byte arrays for equality. Two byte arrays are equal, if they wrap the same number of bytes, and which are equal after byte-wise comparison.</p>
</div>

<h2 id="callableshpp">callables.hpp</h2>
<pre><code class="cpp">#include &lt;multimap/callables.hpp&gt;
namespace multimap
</code></pre>

<p>This file contains some convenient function objects implementing the <a href="#predicate">Predicate</a> interface.</p>
<h3 id="struct-contains">struct Contains</h3>
<p>A function object that checks if a byte array contains another one in terms of a substring. Note that the empty byte array is a substring of any other byte array.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td><code>explicit</code></td>
  <td>
   <code>Contains(const Bytes & bytes)</code>
   <div>Creates a functor that checks for containment of bytes when called.<div>
  </td>
 </tr>
 <tr>
  <td><code>const Bytes &</code></td>
  <td>
   <code>bytes() const</code>
   <div>Returns a read-only reference to the wrapped byte array.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator()(const Bytes & bytes) const</code>
   <div>Returns true if bytes contains the wrapped byte array, false otherwise.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="struct-startswith">struct StartsWith</h3>
<p>A function object that checks if a byte array has a certain prefix.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td><code>explicit</code></td>
  <td>
   <code>StartsWith(const Bytes & bytes)</code>
   <div>Creates a functor that checks if a byte array starts with bytes when called.<div>
  </td>
 </tr>
 <tr>
  <td><code>const Bytes &</code></td>
  <td>
   <code>bytes() const</code>
   <div>Returns a read-only reference to the wrapped byte array.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator()(const Bytes & bytes) const</code>
   <div>Returns true if bytes starts with the wrapped byte array, false otherwise.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="struct-endswith">struct EndsWith</h3>
<p>A function object that checks if a byte array has a certain suffix.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td><code>explicit</code></td>
  <td>
   <code>EndsWith(const Bytes & bytes)</code>
   <div>Creates a functor that checks if a byte array ends with bytes when called.<div>
  </td>
 </tr>
 <tr>
  <td><code>const Bytes &</code></td>
  <td>
   <code>bytes() const</code>
   <div>Returns a read-only reference to the wrapped byte array.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator()(const Bytes & bytes) const</code>
   <div>Returns true if bytes ends with the wrapped byte array, false otherwise.<div>
  </td>
 </tr>
</tbody>
</table>

<h2 id="maphpp">Map.hpp</h2>
<pre><code class="cpp">#include &lt;multimap/Map.hpp&gt;
namespace multimap
</code></pre>

<h3 id="class-map">class Map</h3>
<p>This class implements a 1:n key-value store where each key is associated with a list of values. When putting a key-value pair into the map, the value is appended to the end of the list that is associated with the key. If no such key-list pair already exist, it will be created. Looking up a key returns a read-only iterator for the associated list. If the key does not exist, the list is considered to be empty and the returned iterator has no values to deliver. From a user's point of view there is no distinction between an empty list and a non-existing list.</p>
<p>Map also supports removing or replacing values. When a value is removed, it will be marked as such for the moment making it invisible for subsequent iterations. Running an <a href="#map-optimize">optimze</a> operation removes the data physically. The replace operation is implemented as a remove of the old value followed by an insert/put of the new value. In other words, the replacement is not in-place, but the new value is always the last value in the corresponding list. To restore a certain order an <a href="#map-optimize">optimze</a> operation can be run as well. However, optimization is considered a less frequent, more administrative task.</p>
<p>The class is designed to be a fast and mutable 1:n key-value store. For that reason, Map holds the entire key set in memory. This is also true for keys that were removed from the map at runtime. In addition, each key is associated with a write buffer which altogether contribute a lot to the total memory footprint of the map. Therefore, the number of keys to be put is limited by the amount of available memory. However, this simple design was intended in favour of performance, especially due to the fact that memory is relatively cheap and (server) machines are equipped with more and more of it. As a rule of thumb, assuming keys with 10 bytes in size on average, Map scales up to 10 M keys on desktop machines with 8 GiB of RAM and up to 100 M keys on server machines with 64 GiB of RAM. The number of values, though, is practically limited only by the amount of disk space. For more information, please visit the <a href="../overview/#block-organization">overview</a> page.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Member types</th>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Limits</code>
   <div>Provides static methods to ask for maximum key and value sizes. <a href="#type-maplimits">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Stats</code>
   <div>Type that reports statistical information about an instance of Map. <a href="#type-mapstats">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Iterator</code>
   <div>Input iterator type that reads a list of values. <a href="#type-mapiterator">more...</a><div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td><code>explicit</code></td>
  <td>
   <code>Map(const boost::filesystem::path & directory)</code>
   <div>Opens an already existing map located in directory. <a href="#map-map-directory">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>Map(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(4)</script>const Options & options)</code>
   <div>Opens or creates a map in directory. <a href="#map-map-directory-options">more...</a><div>
  </td>
 </tr>
 <tr>
  <td></td>
  <td>
   <code>~Map()</code>
   <div>Flushes all buffered data to disk, closes the map, and unlocks the directory where the map is located.<div>
  </td>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>put(const Bytes & key, const Bytes & value)</code>
   <div>Appends value to the end of the list associated with key. <a href="#map-put">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>Iterator</code></td>
  <td>
   <code>get(const Bytes & key) const</code>
   <div>Returns a read-only iterator for the list associated with key. <a href="#map-get">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>removeKey(const Bytes & key)</code>
   <div>Removes all values associated with key. <a href="#map-remove-key">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>uint32_t</code>
  </td>
  <td>
   <code>&lt;typename Predicate&gt;</code><br>
   <code>removeKeys(Predicate predicate)</code>
   <div>Removes all values associated with keys for which predicate yields true. <a href="#map-remove-keys">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>bool</code>
  </td>
  <td>
   <code>&lt;typename Predicate&gt;</code><br>
   <code>removeValue(const Bytes & key, Predicate predicate)</code>
   <div>Removes the first value from the list associated with key for which predicate yields true. <a href="#map-remove-value">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>uint32_t</code>
  </td>
  <td>
   <code>&lt;typename Predicate&gt;</code><br>
   <code>removeValues(const Bytes & key, Predicate predicate)</code>
   <div>Removes all values from the list associated with key for which predicate yields true. <a href="#map-remove-values">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>bool</code>
  </td>
  <td>
   <code>&lt;typename Function&gt;</code><br>
   <code>replaceValue(const Bytes & key, Function map)</code>
   <div>Replaces the first value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced. <a href="#map-replace-value">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>uint32_t</code>
  </td>
  <td>
   <code>&lt;typename Function&gt;</code><br>
   <code>replaceValues(const Bytes & key, Function map)</code>
   <div>Replaces each value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced. <a href="#map-replace-values">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>replaceValues(const Bytes & key,</code><br>
   <code><script>nbsp(14)</script>const Bytes & old_value,</code><br>
   <code><script>nbsp(14)</script>const Bytes & new_value)</code>
   <div>Replaces each value in the list associated with key which is equal to old_value by new_value. <a href="#map-replace-values-old-new">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>void</code>
  </td>
  <td>
   <code>&lt;typename Procedure&gt;</code><br>
   <code>forEachKey(Procedure process) const</code>
   <div>Applies process to each key whose list is not empty. <a href="#map-for-each-key">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>void</code>
  </td>
  <td>
   <code>&lt;typename Procedure&gt;</code><br>
   <code>forEachValue(const Bytes & key, Procedure process) const</code>
   <div>Applies process to each value associated with key. <a href="#map-for-each-value">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>template</code><br>
    <code>void</code>
  </td>
  <td>
   <code>&lt;typename BinaryProcedure&gt;</code><br>
   <code>forEachEntry(BinaryProcedure process) const</code>
   <div>Applies process to each key-iterator pair. <a href="#map-for-each-entry">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>size_t</code>
  </td>
  <td>
   <code>getNumPartitions() const</code>
   <div>Returns the number of partitions. This value could be different from that specified in options when creating the map due to the fact that the next prime number has been taken.<div>
  </td>
 </tr>
 <tr>
 <tr>
  <td>
    <code>std::vector&lt;Stats&gt;</code>
  </td>
  <td>
   <code>getStats() const</code>
   <div>Returns statistical information about each partition of the map. <a href="#map-get-stats">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>Stats</code>
  </td>
  <td>
   <code>getTotalStats() const</code>
   <div>Returns statistical information about the map. <a href="#map-get-total-stats">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>bool</code>
  </td>
  <td>
   <code>isReadOnly() const</code>
   <div>Returns true if the map is read-only, false otherwise.<div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Static member functions</th>
 </tr>
 <tr>
  <td>
    <code>std::vector&lt;Stats&gt;</code>
  </td>
  <td>
   <code>stats(const boost::filesystem::path & directory)</code>
   <div>Returns statistical information about each partition of the map located in directory. <a href="#map-stats">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>importFromBase64(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(17)</script>const boost::filesystem::path & input)</code>
   <div>Imports key-value pairs from an input file or directory into the map located in directory. <a href="#map-import-from-base64">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>importFromBase64(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(17)</script>const boost::filesystem::path & input)</code><br>
   <code><script>nbsp(17)</script>const Options & options)</code>
   <div>Same as before, but gives the user more control by providing an <a href="#class-options">Options</a> parameter which is passed to the constructor of Map when opening. This way a map can be created if it does not already exist. <a href="#map-map-directory-options">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>exportToBase64(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(15)</script>const boost::filesystem::path & output)</code>
   <div>Exports all key-value pairs from the map located in directory to a file denoted by output. <a href="#map-export-to-base64">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>exportToBase64(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(15)</script>const boost::filesystem::path & output,</code><br>
   <code><script>nbsp(15)</script>const Options & options)</code>
   <div>Same as before, but gives the user more control by providing an <a href="#class-options">Options</a> parameter. Most users will use this to pass a compare function that triggers a sorting of all lists before exporting them.<div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>optimize(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(9)</script>const boost::filesystem::path & output)</code>
   <div>Rewrites the map located in directory to the directory denoted by output performing various optimizations. <a href="#map-optimize">more...</a><div>
  </td>
 </tr>
 <tr>
  <td>
    <code>void</code>
  </td>
  <td>
   <code>optimize(const boost::filesystem::path & directory,</code><br>
   <code><script>nbsp(9)</script>const boost::filesystem::path & output,</code><br>
   <code><script>nbsp(9)</script>const Options & options)</code>
   <div>Same as before, but gives the user more control by providing an <a href="#class-options">Options</a> parameter. Most users will use this to pass a compare function that triggers a sorting of all lists.<div>
  </td>
 </tr>
</tbody>
</table>

<div class="reference-more">
 <h4 id="map-map-directory"><code>explicit Map::Map(const boost::filesystem::path & directory)</code></h4>
 <p>Opens an already existing map located in directory.</p>
 <p><span class="acquires" />a <a href="#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error" target="_blank">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li>the directory does not exist</li>
  <li>the directory cannot be locked</li>
  <li>the directory does not contain a map</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-map-directory-options">
  <code>Map::Map(const boost::filesystem::path & directory,</code><br>
  <code><script>nbsp(9)</script>const Options & options)</code>
 </h4>
 <p>Opens or creates a map in directory. For the latter, you need to set <code>options.create_if_missing = true</code>. If an error should be raised in case the map already exists, set <code>options.error_if_exists = true</code>. When a new map is created other fields in options are used to configure the map's block size and number of partitions. See <a href="#optionshpp">Options</a> for more information.</p>
 <p><span class="acquires" />a <a href="#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error" target="_blank">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li>the directory does not exist</li>
  <li>the directory cannot be locked</li>
 </ul>
 <p>when <code>options.create_if_missing = false</code> (which is the default)</p>
 <ul>
  <li>the directory does not contain a map</li>
 </ul>
 <p>when <code>options.create_if_missing = true</code> and no map exists</p>
 <ul>
  <li><code>options.block_size</code> is zero</li>
  <li><code>options.block_size</code> is not a power of two</li>
  <li><code>options.buffer_size</code> is not a multiple of the block size</li>
 </ul>
 <p>when <code>options.error_if_exists = true</code></p>
 <ul>
  <li>the directory already contains a map</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-put"><code>void Map::put(const Bytes & key, const Bytes & value)</code></h4>
 <p>Appends value to the end of the list associated with key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#writer-lock">writer lock</a> on the map object.</li>
  <li>a <a href="#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error" target="_blank">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li><code>key.size() > Map::Limits::maxKeySize()</code></li>
  <li><code>value.size() > Map::Limits::maxValueSize()</code></li>
  <li>the map was opened in read-only mode</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-get"><code>Map::Iterator Map::get(const Bytes & key) const</code></h4>
 <p>Returns a read-only iterator for the list associated with key. If the key does not exist, an empty iterator that has no values is returned. A non-empty iterator owns a lock on the associated list that is released automatically when the lifetime of the iterator ends. Note that objects of class <a href="#type-mapiterator">Map::Iterator</a> are moveable.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#reader-lock">reader lock</a> on the list associated with key.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-remove-key"><code>bool Map::removeKey(const Bytes & key)</code></h4>
 <p>Removes all values associated with key.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />true if any values have been removed, false otherwise.</p>
</div>

<div class="reference-more">
 <h4 id="map-remove-keys">
  <code>template &lt;typename Predicate&gt;</code><br>
  <code>uint32_t Map::removeKeys(Predicate predicate)</code>
 </h4>
 <p>Removes all values associated with keys for which predicate yields true. The predicate can be any callable that implements the <a href="#predicate">Predicate</a> interface.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#writer-lock">writer lock</a> on lists associated with matching keys.</li>
 </ul>
 <p><span class="returns" />the number of keys for which any values have been removed.</p>
</div>

<div class="reference-more">
 <h4 id="map-remove-value">
  <code>template &lt;typename Predicate&gt;</code><br>
  <code>bool Map::removeValue(const Bytes & key, Predicate predicate)</code>
 </h4>
 <p>Removes the first value from the list associated with key for which predicate yields true. The predicate can be any callable that implements the <a href="#predicate">Predicate</a> interface.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />true if any value has been removed, false otherwise.</p>
</div>

<div class="reference-more">
 <h4 id="map-remove-values">
  <code>template &lt;typename Predicate&gt;</code><br>
  <code>uint32_t Map::removeValues(const Bytes & key, Predicate predicate)</code>
 </h4>
 <p>Removes all values from the list associated with key for which predicate yields true. The predicate can be any callable that implements the <a href="#predicate">Predicate</a> interface.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />the number of values removed.</p>
</div>

<div class="reference-more">
 <h4 id="map-replace-value">
  <code>template &lt;typename Function&gt;</code><br>
  <code>bool Map::replaceValue(const Bytes & key, Function map)</code>
 </h4>
 <p>Replaces the first value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced. The map function can be any callable that implements the <a href="#function">Function</a> interface.</p>
 <p>Note that a replace operation is actually implemented in terms of a remove of the old value followed by an insert/put of the new value. Thus, the new value is always the last value in the list. In other words, the replacement is not in-place.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />true if any value has been replaced, false otherwise.</p>
</div>

<div class="reference-more">
 <h4 id="map-replace-values">
  <code>template &lt;typename Function&gt;</code><br>
  <code>uint32_t Map::replaceValues(const Bytes & key, Function map)</code>
 </h4>
 <p>Replaces each value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced. The map function can be any callable that implements the <a href="#function">Function</a> interface.</p>
 <p>Note that a replace operation is actually implemented in terms of a remove of the old value followed by an insert/put of the new value. Thus, the new value is always the last value in the list. In other words, the replacement is not in-place.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />the number of values replaced.</p>
</div>

<div class="reference-more">
 <h4 id="map-replace-values-old-new">
  <code>uint32_t Map::replaceValues(const Bytes & key, </code><br>
  <code><script>nbsp(28)</script>const Bytes & old_value,</code><br>
  <code><script>nbsp(28)</script>const Bytes & new_value)</code>
 </h4>
 <p>Replaces each value in the list associated with key which is equal to old_value by new_value.</p>
 <p>Note that a replace operation is actually implemented in terms of a remove of the old value followed by an insert/put of the new value. Thus, the new value is always the last value in the list. In other words, the replacement is not in-place.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#writer-lock">writer lock</a> on the list associated with key.</li>
 </ul>
 <p><span class="returns" />the number of values replaced.</p>
</div>

<div class="reference-more">
 <h4 id="map-for-each-key">
  <code>template &lt;typename Procedure&gt;</code><br>
  <code>void Map::forEachKey(Procedure process) const</code>
 </h4>
 <p>Applies process to each key whose list is not empty. The process argument can be any callable that implements the <a href="#procedure">Procedure</a> interface. </p>
 <p><span class="acquires" />a <a href="#reader-lock">reader lock</a> on the map object.</p>
</div>

<div class="reference-more">
 <h4 id="map-for-each-value">
  <code>template &lt;typename Procedure&gt;</code><br>
  <code>void Map::forEachValue(const Bytes & key, Procedure process) const</code>
 </h4>
 <p>Applies process to each value associated with key. The process argument can be any callable that implements the <a href="#procedure">Procedure</a> interface. </p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#reader-lock">reader lock</a> on the list associated with key.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-for-each-entry">
  <code>template &lt;typename BinaryProcedure&gt;</code><br>
  <code>void Map::forEachEntry(BinaryProcedure process) const</code>
 </h4>
 <p>Applies process to each key-iterator pair. The process argument can be any callable that implements the <a href="#binaryprocedure">BinaryProcedure</a> interface. </p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#reader-lock">reader lock</a> on the list that is currently processed.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-get-stats">
  <code>std::vector&lt;<a href="#type-mapstats">Map::Stats</a>&gt; Map::getStats() const</code>
 </h4>
 <p>Returns statistical information about each partition of the map. This operation requires a traversal of the entire map visiting each entry.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#reader-lock">reader lock</a> on the list that is currently visited.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-get-total-stats">
  <code><a href="#type-mapstats">Map::Stats</a> Map::getTotalStats() const</code>
 </h4>
 <p>Returns statistical information about the map. In fact, this method computes the total values from the result returned by calling the previous method.</p>
 <p><span class="acquires" /></p>
 <ul>
  <li>a <a href="#reader-lock">reader lock</a> on the map object.</li>
  <li>a <a href="#reader-lock">reader lock</a> on the list that is currently visited.</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-stats">
  <code>static std::vector&lt;<a href="#type-mapstats">Map::Stats</a>&gt; Map::stats(</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & directory)</code>
 </h4>
 <p>Returns statistical information about each partition of the map located in directory. This method is similar to <a href="#map-get-stats">Map::getStats()</a> except that the map does not need to be instanciated.</p>
 <p><span class="acquires" />a <a href="#directory-lock">directory lock</a> on directory.</p>
</div>

<div class="reference-more">
 <h4 id="map-import-from-base64">
  <code>static void Map::importFromBase64(</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & directory,</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & input)</code>
 </h4>
 <p>Imports key-value pairs from an input file or directory into the map located in directory. If input refers to a directory all files in that directory will be imported, except hidden files starting with a dot and other sub-directories. A description of the file format can be found in the <a href="overview/#multimap-import">overview</a> section.</p>
 <p><span class="acquires" />a <a href="#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /> everything thrown by the constructor of class <a href="#class-map">Map</a> or <a href="http://en.cppreference.com/w/cpp/error/runtime_error" target="_blank">std::runtime_error</a> if the input file or directory cannot be read.</p>
</div>

<div class="reference-more">
 <h4 id="map-export-to-base64">
  <code>static void Map::exportToBase64(</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & directory,</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & output)</code>
 </h4>
 <p>Exports all key-value pairs from the map located in directory to a file denoted by output. If the file already exists, its content will be overwritten. The generated file is in canonical form as described in the <a href="overview/#multimap-export">overview</a> section.</p>
 <p><span class="acquires" />a <a href="#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error" target="_blank">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li>the directory does not exist</li>
  <li>the directory cannot be locked</li>
  <li>the directory does not contain a map</li>
  <li>the creation of the output file failed</li>
 </ul>
</div>

<div class="reference-more">
 <h4 id="map-optimize">
  <code>static void Map::optimize(</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & directory,</code><br>
  <code><script>nbsp(8)</script>const boost::filesystem::path & output)</code>
 </h4>
 <p>Rewrites the map located in directory to the directory denoted by output performing various optimizations. For more details please refer to the <a href="overview/#multimap-optimize">overview</a> section.</p>
 <p><span class="acquires" />a <a href="#directory-lock">directory lock</a> on directory.</p>
 <p><span class="throws" /><a href="http://en.cppreference.com/w/cpp/error/runtime_error" target="_blank">std::runtime_error</a> if one of the following is true:</p>
 <ul>
  <li>the directory does not exist</li>
  <li>the directory cannot be locked</li>
  <li>the directory does not contain a map</li>
  <li>the creation of a new map in output failed</li>
 </ul>
</div>

<h3 id="type-mapiterator">type Map::Iterator</h3>
<p>This type represents an iterator to read a list of values, possibly by streaming them from an external device.</p>
<p>The iterator supports lazy initialization, which means that no I/O operation is performed until a value is actually requested. This might be useful in cases where multiple iterators have to be collected first to determine in which order they have to be processed.</p>
<p>The iterator also owns a reader lock for the underlying list for synchronization purposes. This lock is automatically released when the iterator's destructor is called.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>available() const</code>
   <div>Returns the remaining number of values to be iterated. Calling this method does not trigger any I/O operation.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>hasNext() const</code>
   <div>Returns true if the iterator has more values, false otherwise.<div>
  </td>
 </tr>
 <tr>
  <td><code>Bytes</code></td>
  <td>
   <code>next()</code>
   <div>Returns the next value from the underlying list and moves the iterator once forward. <a href="#map-iterator-next">more...</a><div>
  </td>
 </tr>
 <tr>
  <td><code>Bytes</code></td>
  <td>
   <code>peekNext()</code>
   <div>Same as before, but does not move the iterator once forward.<div>
  </td>
 </tr>
</tbody>
</table>

<div class="reference-more">
 <h4 id="map-iterator-next">
  <code><a href="#class-bytes">Bytes</a> Map::Iterator::next()</code>
 </h4>
 <p>Returns the next value from the underlying list and moves the iterator once forward. The returned <a href="#class-bytes">Bytes</a> object points to data managed by the iterator and is only valid for read access until the next call of this method. Reading from invalid data is undefined behavior. A deep copy of the value can be created by either calling its <a href="#bytes-tostring">toString()</a> method or <a href="http://en.cppreference.com/w/cpp/string/byte/memcpy" target="_blank">std::memcpy()</a> its data into another buffer.</p>
 <p><span class="requires" /><code>hasNext()</code> yields true.</p>
</div>

<h3 id="type-maplimits">type Map::Limits</h3>
<p>This type represents a namespace that provides static methods for obtaining system limitations. Those limits which define constraints on user supplied data also serve as preconditions.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Static member functions</th>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>maxKeySize()</code>
   <div>Returns the maximum size in number of bytes for a key to put.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>maxValueSize()</code>
   <div>Returns the maximum size in number of bytes for a value to put.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="type-mapstats">type Map::Stats</h3>
<p>This type is a pure data holder for reporting statistical information.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Data members</th>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>block_size</code>
   <div>Tells the block size of the map or partition which was defined in <a href="#class-options">Options</a> when creating the map.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>key_size_avg</code>
   <div>Tells the average size in number of bytes of all keys in a map or partition. Note that keys that are currently not associated with any value are not taken into account.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>key_size_max</code>
   <div>Tells the size in number of bytes of the largest key in a map or partition.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>key_size_min</code>
   <div>Tells the size in number of bytes of the smallest key in a map or partition.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>list_size_avg</code>
   <div>Tells the average number of values associated with a key in a map or partition. Note that keys that are currently not associated with any value are not taken into account.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>list_size_max</code>
   <div>Tells the largest number of values associated with a key in a map or partition.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>list_size_min</code>
   <div>Tells the smallest number of values associated with a key in a map or partition. Note that keys that are currently not associated with any value are not taken into account.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_blocks</code>
   <div>Tells the number of blocks currently written to disk. Note that in-memory write buffer blocks that are associated with each keys are not taken into account. For more details please refer to the <a href="overview/#block-organization">overview</a> section.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_keys_total</code>
   <div>Tells the total number of keys in a map or partition, including keys that are currently not associated with any value.
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_keys_valid</code>
   <div>Tells the number of valid keys in a map or partition. A valid key is associated with at least one value.
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_values_total</code>
   <div>Tells the total number of values in a map or partition, including values that are marked as removed. Note that this number can only be decreased by running an <a href="overview/#multimap-optimize">optimize</a> operation.
  </td>
 </tr>
 <tr>
  <td><code>uint64_t</code></td>
  <td>
   <code>num_values_valid</code>
   <div>Tells the number of values in a map or partition that are not marked as removed.</div>
  </td>
 </tr>
</tbody>
</table>

<h2 id="optionshpp">Options.hpp</h2>
<pre><code class="cpp">#include &lt;multimap/Options.hpp&gt;
namespace multimap
</code></pre>

<h3 id="class-options">class Options</h3>
<p>This class is a pure data holder used for configuration purposes.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Data members</th>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>block_size</code>
   <div>Defines the block size in number of bytes for a newly created map or partition. The value must be a power of two. Typical block sizes are 128, 256, 512 (default), 1024, or even larger. Please refer to the <a href="overview/#block-organization">overview</a> section for more details.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>num_partitions</code>
   <div>Defines the number of partitions for a newly created map. The purpose of partitioning is to increase the performance of the <a href="overview/#multimap-export">export</a> and <a href="overview/#multimap-optimize">optimize</a> operations by applying a divide and conquer method. A suitable number can be estimated like this: "total number of value-bytes to be put" divided by "the memory allowed to be used running the operation". An underestimate can lead to long runtimes for the mentioned operations. The default value is 23; other values will be rounded to the next prime number that is greater or equal to the given value.<div>
  </td>
 </tr>
 <tr>
  <td><code>uint32_t</code></td>
  <td>
   <code>buffer_size</code>
   <div>Defines the size of an internal buffer that contains blocks to be written. The default value is 1 MiB; other values are required to be a multiple of the given block size. Most users should leave this parameter alone.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>create_if_missing</code>
   <div>If set to true, creates a new map if it does not exist. The default value is false.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>error_if_exists</code>
   <div>If set to true, throws an exception if a map already exists. The default value is false.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>readonly</code>
   <div>If set to true, opens a map in read-only mode. In this mode all operations that could possibly modify the stored data are not allowed and will throw an exception on an attempt to do so. This flag is useful to prevent unintentional updates of read-only datasets. The default value is false.<div>
  </td>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>quiet</code>
   <div>If set to true, no status information for long running operations are sent to stdout. This flag is useful for writing shell scripts. The default value is false.<div>
  </td>
 </tr>
 <tr>
  <td><code>Compare</code></td>
  <td>
   <code>compare</code>
   <div>A callable that implements the <a href="#compare">Compare</a> interface. It is used to sort lists of values when running certain operations such as <a href="overview/#multimap-export">export</a> or <a href="overview/#multimap-optimize">optimize</a>. Actually this member is a <a href="http://en.cppreference.com/w/cpp/utility/functional/function" target="_blank">function wrapper</a>, not a generic type, which can be left empty (default) if no sorting is desired.<div>
  </td>
 </tr>
 <tr>
  <th colspan="2">Member functions</th>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>keepNumPartitions()</code>
   <div>Sets <code>num_partitions</code> to a special value that indicates to the <a href="overview/#multimap-optimize">optimize</a> operation that the number of partitions should not be changed. <div>
  </td>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>keepBlockSize()</code>
   <div>Sets <code>block_size</code> to a special value that indicates to the <a href="overview/#multimap-optimize">optimize</a> operation that the block size should not be changed.<div>
  </td>
 </tr>
</tbody>
</table>

<h2 id="interfaces">Interfaces</h2>
<p>The interfaces described here are requirements expected by some user-provided function objects. They are typically employed as template parameters and are not to be confused with abstract classes used in object-oriented programming. Sometimes this type of interfaces is also referred to as <a href="http://en.cppreference.com/w/cpp/concept" target="_blank">Concepts</a>.</p>
<h3 id="compare">Compare</h3>
<p>A callable that is applied to two instances of class <a href="#class-bytes">Bytes</a> returning a boolean that tells if the left operand is less than the right operand. This interface is equivalent to the Compare concept described <a href="http://en.cppreference.com/w/cpp/concept/Compare">here</a>. Objects implementing this interface are typically used by sorting algorithms.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator()(const Bytes & lhs, const Bytes & rhs) const</code>
   <div>Returns true if lhs is considered less than rhs, false otherwise.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="function">Function</h3>
<p>A callable that is applied to an instance of class <a href="#class-bytes">Bytes</a> returning a standard string. The returned string serves as a managed byte buffer and may contain arbitrary data. Objects implementing this interface are typically used for mapping input values to output values in replace operations.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>std::string</code></td>
  <td>
   <code>operator()(const Bytes & bytes) const</code>
   <div>Maps the given byte array to another byte array returned as standard string.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="predicate">Predicate</h3>
<p>A callable that is applied to an instance of class <a href="#class-bytes">Bytes</a> returning a boolean value. Objects implementing this interface are typically used to qualify keys or values for some further operation.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>bool</code></td>
  <td>
   <code>operator()(const Bytes & bytes) const</code>
   <div>Returns a boolean value after evaluating the given byte array.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="procedure">Procedure</h3>
<p>A callable that is applied to an instance of class <a href="#class-bytes">Bytes</a> without returning any value. Procedures can have state that may change during application. Objects implementing this interface are typically used to visit keys or values, e.g. to collect information about them.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>operator()(const Bytes & bytes)</code>
   <div>Processes the given byte array, possibly changing the callable's state.<div>
  </td>
 </tr>
</tbody>
</table>

<h3 id="binaryprocedure">BinaryProcedure</h3>
<p>A callable that is applied to a pair of objects without returning a value. The first object being an instance of class <a href="#class-bytes">Bytes</a> and the second object being an instance of class <a href="#type-mapiterator">Map::Iterator</a>. Binary procedures can have state that may change during application. Objects implementing this interface are typically used to visit entries when traversing a map.</p>
<table class="reference-table">
<tbody>
 <tr>
  <th colspan="2">Required member function</th>
 </tr>
 <tr>
  <td><code>void</code></td>
  <td>
   <code>operator()(const Bytes & key, Map::Iterator iterator)</code>
   <div>Processes a list iterator that is associated with key, possibly changing the callable's state. Note that as long as the iterator is alive, the corresponding list is locked by a <a href="#reader-lock">reader lock</a>.<div>
  </td>
 </tr>
</tbody>
</table>

<h2 id="locking">Locking</h2>
<p>Multimap makes use of three kinds of locks in order to synchronize concurrent access to objects of type <a href="#class-map">Map</a>.</p>
<h3 id="directory-lock">Directory Lock</h3>
<p>A directory lock is a simple file located in the directory where a map lives. Such a file is created when a <a href="#class-map">Map</a> object is instantiated or any of its static member functions is called. When the object gets destructed or the function terminates the file is automatically deleted. The directory lock ensures that only one process can access a map at the same time.</p>
<h3 id="reader-lock">Reader Lock</h3>
<p>A reader lock, also called shared lock, locks an object for read-only access. Multimap uses such locks to protect lists of values that are currently in use against modification by other threads. However, a single list can be read-locked by multiple threads at the same time.</p>
<p>A reader lock is typically wrapped and owned by an iterator returned from calling <a href="#map-get">Map::get()</a>. According to <a href="http://en.cppreference.com/w/cpp/language/raii" target="_blank">RAII</a> the lock is automatically released when the iterator gets destructed. Any method of <a href="#class-map">Map</a> that needs to acquire a reader lock to perform its operation will block if the resource is currently locked by a writer lock and until this lock is released.</p>
<h3 id="writer-lock">Writer Lock</h3>
<p>A writer lock, also called exclusive or unique lock, locks an object for read-write access. Multimap uses such locks to gain exclusive access to lists of values for modification purposes. When a list is locked by a writer lock it cannot be locked by any other reader or writer lock at the same time.</p>
<p>Unlike reader locks that are wrapped by iterators, the ownership of writer locks is never transferred to the client in order to reduce the risk of running into deadlocks. Nevertheless, iterators that allow the modification of the underlying list are used inside the library. So, any method of <a href="#class-map">Map</a> that needs to acquire a writer lock to perform its operation will block if the resource is currently locked either by a reader lock or writer lock, and until this lock is released.</p>
              </div>
              <div class="col-md-3" role="complementary">
                <nav id="multimap-sidebar"
                     class="hidden-print hidden-xs hidden-sm affix-top"
                     data-spy="affix" data-offset-top="130" data-offset-bottom="200">
                  <ul class="nav">
                    
                      <li><a href="#byteshpp">Bytes.hpp</a>
                        <ul>
                          
                          <li><a href="#class-bytes">class Bytes</a></li>
                          
                        </ul>
                      </li>
                    
                      <li><a href="#callableshpp">callables.hpp</a>
                        <ul>
                          
                          <li><a href="#struct-contains">struct Contains</a></li>
                          
                          <li><a href="#struct-startswith">struct StartsWith</a></li>
                          
                          <li><a href="#struct-endswith">struct EndsWith</a></li>
                          
                        </ul>
                      </li>
                    
                      <li><a href="#maphpp">Map.hpp</a>
                        <ul>
                          
                          <li><a href="#class-map">class Map</a></li>
                          
                          <li><a href="#type-mapiterator">type Map::Iterator</a></li>
                          
                          <li><a href="#type-maplimits">type Map::Limits</a></li>
                          
                          <li><a href="#type-mapstats">type Map::Stats</a></li>
                          
                        </ul>
                      </li>
                    
                      <li><a href="#optionshpp">Options.hpp</a>
                        <ul>
                          
                          <li><a href="#class-options">class Options</a></li>
                          
                        </ul>
                      </li>
                    
                      <li><a href="#interfaces">Interfaces</a>
                        <ul>
                          
                          <li><a href="#compare">Compare</a></li>
                          
                          <li><a href="#function">Function</a></li>
                          
                          <li><a href="#predicate">Predicate</a></li>
                          
                          <li><a href="#procedure">Procedure</a></li>
                          
                          <li><a href="#binaryprocedure">BinaryProcedure</a></li>
                          
                        </ul>
                      </li>
                    
                      <li><a href="#locking">Locking</a>
                        <ul>
                          
                          <li><a href="#directory-lock">Directory Lock</a></li>
                          
                          <li><a href="#reader-lock">Reader Lock</a></li>
                          
                          <li><a href="#writer-lock">Writer Lock</a></li>
                          
                        </ul>
                      </li>
                    
                  </ul>
                  <div id="back-to-top">
                    <a href="#top">Back to top</a>
                  </div>
                </nav>
              </div>
            
          </div>
        </div>
        <br>
        <br>
        <br>
      
    </div>
    
    <footer id="footer">
      <div class="container">
        <a href="http://www.gnu.org/licenses/agpl-3.0.en.html" target="_blank">
          <img style="float:right" src="../img/agpl-v3-logo-white-on-gray.png" />
        </a>
        <p>
          <i class="fa fa-copyright"></i> 2015-2016 by <a href="https://github.com/mtrenkmann" target="_blank">Martin Trenkmann</a>
        </p>
        <p>Documentation built with <a href="http://getbootstrap.com/" target="_blank">Bootstrap</a>
          &middot; <a href="http://www.tipo.net.ar/" target="_blank">Faster One</a>
          &middot; <a href="http://www.carrois.com/fira-4-1/" target="_blank">Fira</a>
          &middot; <a href="http://fontawesome.io/" target="_blank">Font Awesome</a>
          &middot; <a href="https://highlightjs.org/" target="_blank">highlight.js</a>
          &middot; <a href="https://daringfireball.net/projects/markdown/" target="_blank">Markdown</a>
          &middot; <a href="http://www.mkdocs.org/" target="_blank">MkDocs</a></p>
      </div>
    </footer>
  </body>
</html>
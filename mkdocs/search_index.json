{
    "docs": [
        {
            "location": "/", 
            "text": "Multimap is a fast 1:n key-value store that provides a mapping from keys to lists of values. The library is named after the \ndata structure\n you might already know from your very first computer science course, but beyond that it handles the external persistent storage of the entire data. Because Multimap is optimized for large numbers of n, it works perfectly as a building block for retrieval systems that employ \ninverted indexing\n.\n\n\n\n  \n\n    \nFeatures\n\n    \n\n    \nEmbeddable store with a clean \nC++\n and \nJava interface\n.\n\n    \nSupported operations: put, get, remove, replace.\n\n    \nKeys and values are arbitrary byte arrays.\n\n    \nKeys are hold in memory, values are stored on disk.\n\n    \nImport/export from/to Base64-encoded text files.\n\n    \nFull thread-safe.\n\n    \n\n  \n\n  \n\n    \nGet Started\n\n    \n\n    \nRead the \noverview\n and learn the basics.\n\n    \nTry the \nC++\n or \nJava tutorial\n to get familiar with the API.\n\n    \n\n    \n\n    \n\n      \n\n        \n\n      \n\n      \n\n        Download \nmultimap-0.3.0.tar.gz\n\n        \nInstallation instructions for \nC++\n and \nJava\n\n      \n\n    \n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\nC++ Example\n\n\n\n\n#include \nmultimap/Map.hpp\n\n\nint main() {\n  multimap::Options options;\n  options.create_if_missing = true;\n  multimap::Map map(\npath/to/directory\n, options);\n\n  map.put(\nkey\n, \n1st value\n);\n  map.put(\nkey\n, \n2nd value\n);\n\n  auto iter = map.get(\nkey\n);\n  while (iter.hasNext()) {\n    doSomething(iter.next());\n  }\n\n  // d'tor of iter releases internal reader lock.\n  // d'tor of map flushes in-memory data to disk. \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJava Example\n\n\n\n\nimport io.multimap.*;\n\npublic static void main(String[] args) {\n  Options options = new Options();\n  options.setCreateIfMissing(true);\n  Map map = new Map(\npath/to/directory\n, options);\n\n  map.put(\nkey\n, \n1st value\n);\n  map.put(\nkey\n, \n2nd value\n);\n\n  Iterator iter = map.get(\nkey\n);\n  while (iter.hasNext()) {\n    doSomething(iter.next());\n  }\n\n  iter.close();\n  map.close();\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMultimap is \nfree software\n implemented in standard C++11 and POSIX, distributed under the terms of the \nGNU Affero General Public License\n (AGPL) version 3. At this time, Multimap runs under GNU/Linux on x86-64 and x86-32. This is also true for the included Java binding.", 
            "title": "Home"
        }, 
        {
            "location": "/overview/", 
            "text": "How It Works\n\n\nMultimap is implemented as an in-memory hash table which maps each key to a list of values. Keys and values are arbitrary byte arrays. The following schema illustrates the general design:\n\n\na\n -\n 1, 2, 3, 4, 5, 6\n\nb\n -\n 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17\n\nc\n -\n 18, 19, 20, 21, 22, 23, 24\n\n\n\n\nPutting a key-value pair into the map adds the value to the end of the list associated with the key. If no such list already exists it will be created. Looking up the key returns a read-only iterator to this list. If the key does not exist or the associated list is empty, the iterator is empty, i.e. it won't yield any value. \n\n\nRemoving a value from a list means to mark it as deleted, so that iterators will ignore such values. Removed values will remain on disk until an \noptimize\n operation has been run.\n\n\nReplacing a value is implemented in terms of removing the old value followed by putting the new value. As a consequence, the new value always appears at the end of the list. Values that have been replaced also remain on disk and can only be deleted physically by running an \noptimize\n operation. The same is true to bring the values in certain order back again after performing replace operations.\n\n\nBlock Organization\n\n\nAn important aspect of Multimap's design is that all lists are organized in blocks of data. The size of these blocks is fixed and can be chosen when a new instance is created. Typical block sizes in number of bytes are 64, 128, 256, 512, 1024, or even larger, and yes, it has to be a power of two. The schema, therefore, could be updated as follows:\n\n\na\n -\n [1, 2, 3], [4, 5, 6]\n\nb\n -\n [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, free]\n\nc\n -\n [18, 19, 20], [21, 22, 23], [24, free]\n\n\n\n\nAt runtime only the last block of each list is held in memory used as a write buffer. Preceding blocks are written to disk as soon as they are filled up, replaced by an id for later referencing. A single value might span multiple blocks if it does not fit into the last one. The schema now shows the structure that actually remains in memory.\n\n\na\n -\n b1, [4, 5, 6]\n\nb\n -\n b2, b3, b4, [16, 17, free]\n\nc\n -\n b5, b6, [24, free]\n\n\n\n\nHence, the total memory consumption of a map depends on\n\n\n\n\nthe number and size of keys\n\n\nthe number of block ids which is proportional to the number of values\n\n\nthe block size, because unless the list is empty its last block is always allocated\n\n\n\n\nTo estimate the memory footprint the following equation can be used:\n\n\nmem_total = 1.5 * (mem_keys + mem_block_ids + mem_last_blocks)\n          = 1.5 * (num_keys * (avg_key_size + block_size) + (num_blocks * 3.1))\n\n\n\n\nwhere\n\n\nmem_keys        = num_keys * avg_key_size\nmem_block_ids   = num_blocks * 3.1\nmem_last_blocks = num_keys * block_size\nnum_blocks      = (num_values * avg_value_size) / block_size\n\n\n\n\nAssuming a key set consisting of words from an English dictionary with an average key size of 5 bytes, the factor that has the biggest impact on the total memory footprint is the block size. Therefore, it is important to choose a value that is most suitable for the given use case to prevent running out of memory.\n\n\nLarge block sizes can improve I/O performance since more data is transferred at once. In contrast, large block sizes lead to higher memory consumption at runtime. As a rule of thumb, if a key set is small a larger block size should be chosen and vice versa. Of course, what is small and what is large depends on the given hardware. Try to make estimates and test different settings.\n\n\nHere are a some examples:\n\n\n\n\n\n\n\n\nnum_keys\n\n\navg_key_size\n\n\nnum_blocks\n\n\nblock_size\n\n\nmemory\n\n\n\n\n\n\n\n\n\n\n1 000 000\n\n\n5 bytes\n\n\n100 000 000\n\n\n512 bytes\n\n\n1.12 GiB\n\n\n\n\n\n\n2 000 000\n\n\n5 bytes\n\n\n100 000 000\n\n\n512 bytes\n\n\n1.77 GiB\n\n\n\n\n\n\n2 000 000\n\n\n10 bytes\n\n\n100 000 000\n\n\n512 bytes\n\n\n1.77 GiB\n\n\n\n\n\n\n2 000 000\n\n\n10 bytes\n\n\n200 000 000\n\n\n512 bytes\n\n\n2.22 GiB\n\n\n\n\n\n\n2 000 000\n\n\n10 bytes\n\n\n200 000 000\n\n\n1024 bytes\n\n\n3.68 GiB\n\n\n\n\n\n\n10 000 000\n\n\n10 bytes\n\n\n1 000 000 000\n\n\n64 bytes\n\n\n6.19 GiB\n\n\n\n\n\n\n10 000 000\n\n\n10 bytes\n\n\n1 000 000 000\n\n\n128 bytes\n\n\n6.87 GiB\n\n\n\n\n\n\n\n\nSerialization\n\n\nAs mentioned previously, keys and values are arbitrary byte arrays. This has the advantage that Multimap does not need to deal with packing/unpacking of user-defined data types and leaves the door open for compression (currently not applied). For the user this has the advantage that he/she can stick with his/her preferred serialization method.\n\n\nOn the other hand, this approach has the disadvantage that values are seen as \nbinary large objects\n with no type information. In other words, a value is treated as one entity and therefore can only be deleted or replaced as a whole. Updates on individual fields of composite types are not possible.\n\n\n\n\n\nFor more information please refer to Wikipedia's \ncomparison of data serialization formats\n.\n\n\nCommand Line Tool\n\n\nMultimap also comes with a command line tool that can and should be installed in addition to the shared library. The tool allows you to perform some administration operations right in your terminal. Here is the help page:\n\n\n$ multimap help\nUSAGE\n\n  multimap COMMAND PATH_TO_MAP [PATH] [OPTIONS]\n\nCOMMANDS\n\n  help           Print this help message and exit.\n  stats          Print statistics about an instance.\n  import         Import key-value pairs from Base64-encoded text files.\n  export         Export key-value pairs to a Base64-encoded text file.\n  optimize       Rewrite an instance performing various optimizations.\n\nOPTIONS\n\n  --create       Create a new instance if missing when importing data.\n  --bs      NUM  Block size to use for a new instance. Default is 512.\n  --nparts  NUM  Number of partitions to use for a new instance. Default is 23.\n  --quiet        Don't print out any status messages.\n\nEXAMPLES\n\n  multimap stats    path/to/map\n  multimap import   path/to/map path/to/input\n  multimap import   path/to/map path/to/input/base64.csv\n  multimap import   path/to/map path/to/input/base64.csv --create\n  multimap export   path/to/map path/to/output/base64.csv\n  multimap optimize path/to/map path/to/output\n  multimap optimize path/to/map path/to/output --bs 128\n  multimap optimize path/to/map path/to/output --nparts 42\n  multimap optimize path/to/map path/to/output --nparts 42 --bs 128\n\n\nCopyright (C) 2015-2016 Martin Trenkmann\n\nhttp://multimap.io\n\n\n\n\n\n$ multimap stats\n\n\nThis command reports statistical information about a map located in a given directory. A typical output reads as follows:\n\n\n$ multimap stats path/to/map\n#0   block_size        128       ******************************\n#0   key_size_avg      8         ******************************\n#0   key_size_max      40        ******************************\n#0   key_size_min      1         ******************************\n#0   list_size_avg     45        *******************\n#0   list_size_max     974136    ****\n#0   list_size_min     1         ******************************\n#0   num_blocks        3170842   ******************\n#0   num_keys_total    573308    ******************************\n#0   num_keys_valid    573308    ******************************\n#0   num_values_total  25836927  *******************\n#0   num_values_valid  25836927  *******************\n\n#1   block_size        128       ******************************\n#1   key_size_avg      8         ******************************\n#1   key_size_max      40        ******************************\n#1   key_size_min      1         ******************************\n#1   list_size_avg     45        *******************\n#1   list_size_max     1010385   ****\n#1   list_size_min     1         ******************************\n#1   num_blocks        3209400   *******************\n#1   num_keys_total    572406    ******************************\n#1   num_keys_valid    572406    ******************************\n#1   num_values_total  26124736  *******************\n#1   num_values_valid  26124736  *******************\n\n[ #2 .. #22 ]\n\n===  block_size        128      \n===  key_size_avg      8        \n===  key_size_max      40       \n===  key_size_min      1        \n===  list_size_avg     47       \n===  list_size_max     8259736  \n===  list_size_min     1        \n===  num_blocks        77641183 \n===  num_keys_total    13167247 \n===  num_keys_valid    13167247 \n===  num_values_total  629686802\n===  num_values_valid  629686802\n===  num_partitions    23\n\n\n\n\nSince a map is divided into several partitions there is one info block per partition, followed by a final block that states the total numbers. The asterisks visualize the numbers as relative values with respect to the partition with the maximum value in this category. The output can be filtered with a little help from \ngrep\n. For example, a histogram that shows the distribution of values among the partitions can be generated like this:\n\n\n$ multimap stats path/to/map | grep values_total\n#0   num_values_total  25836927  *******************\n#1   num_values_total  26124736  *******************\n#2   num_values_total  25616082  *******************\n#3   num_values_total  24602683  ******************\n#4   num_values_total  23633504  *****************\n#5   num_values_total  25757280  *******************\n#6   num_values_total  24665881  ******************\n#7   num_values_total  24207863  ******************\n#8   num_values_total  36033742  **************************\n#9   num_values_total  27674578  ********************\n#10  num_values_total  41774200  ******************************\n#11  num_values_total  27141930  ********************\n#12  num_values_total  27015011  ********************\n#13  num_values_total  25249784  *******************\n#14  num_values_total  26979204  ********************\n#15  num_values_total  25433887  *******************\n#16  num_values_total  25533309  *******************\n#17  num_values_total  23607578  *****************\n#18  num_values_total  23853340  ******************\n#19  num_values_total  26713848  ********************\n#20  num_values_total  25827632  *******************\n#21  num_values_total  24587953  ******************\n#22  num_values_total  41815850  ******************************\n===  num_values_total  629686802\n\n\n\n\nSimilarly, to print only the total values you can run:\n\n\n$ multimap stats path/to/map | grep =\n===  block_size        128      \n===  key_size_avg      8        \n===  key_size_max      40       \n===  key_size_min      1        \n===  list_size_avg     47       \n===  list_size_max     8259736  \n===  list_size_min     1        \n===  num_blocks        77641183 \n===  num_keys_total    13167247 \n===  num_keys_valid    13167247 \n===  num_values_total  629686802\n===  num_values_valid  629686802\n===  num_partitions    23\n\n\n\n\n$ multimap import\n\n\nThis command allows you to import key-value pairs from Base64-encoded text files. The file format is defined as follows:\n\n\n\n\nThe file is in \nCSV format\n.\n\n\nThe delimiter is whitespace or tab.\n\n\nEach line starts with a key followed by one or more values.\n\n\nMultiple lines may start with the same key.\n\n\nKeys and values are encoded in Base64.\n\n\n\n\nExample (not in Base64 for demonstration purposes):\n\n\nkey1 value1\nkey2 value2 value3\nkey1 value4\nkey3 value5 value6 value7 value8\nkey2 value9\n\n\n\n\nis equivalent to:\n\n\nkey1 value1 value4\nkey2 value2 value3 value9\nkey3 value5 value6 value7 value8\n\n\n\n\nis equivalent to:\n\n\nkey1 value1\nkey1 value4\nkey2 value2\nkey2 value3\nkey2 value9\nkey3 value5\nkey3 value6\nkey3 value7\nkey3 value8\n\n\n\n\nThe second listing is in canonical form, which means that all values sharing the same key are in one line. In other words, in a file that is in canonical form, there are no two lines that begin with the same key.\n\n\n$ multimap export\n\n\nThis command allows you to export all key-value pairs from a map into a single text file. The format of this file follows the description given in the \nprevious section\n. The generated file is in canonical form. This feature is useful for data exchange to other libraries and frameworks, or for backup purposes.\n\n\n$ multimap optimize\n\n\nThe optimize operation rewrites the entire map performing the following tasks:\n\n\n\n\nDefragmentation. All blocks which belong to the same list are written sequentially to disk which improves locality and leads to better read performance.\n\n\nGarbage collection. Values that are marked as deleted won't be copied which reduces the size of the new map and also improves locality.\n\n\n\n\nIn addition, some optional settings can be applied:\n\n\n\n\nNew block size. Changing the block size could be necessary to tweak the memory footprint.\n\n\nList sorting. All lists can be sorted applying a user-defined compare function. This option is only available when using the \nC++\n and \nJava API\n directly.\n\n\n\n\nQ\nA\n\n\n Why are all keys held in memory?\n\n\n Multimap is designed for relatively small keys like dictionary words. Therefore, the footprint of the entire key set is rather small compared to all in-memory blocks that are used as write buffers. Furthermore, the library aims to run on server machines which tend to have more and more memory available. And of course, an internal hash table is a lot faster and easier to maintain than a partly externalized B+ tree or something similar.\n\n\n Why both keys and values have to be byte arrays?\n\n\n Multimap aims to keep things simple. There are plenty of very good \nserialization libraries\n available so that users can freely choose their preferred method. Reading and writing raw binary data also makes Multimap independent from such libraries which in turn facilitates data exchange with different programming languages and/or systems. On the other hand, due to lack of type information Multimap cannot operate on individual fields of composite types without injecting code for packing/unpacking.\n\n\n Why values cannot be replaced in-place?\n\n\n Values are written to disk in the same order as they were put without leaving any gaps. Therefore, if a new value is larger than the old one there is simply not enough room for it. An in-place replacement would be possible, though, if the value size is fixed. Maybe this option will be provided in further releases. Anyway, replacing values is considered a little-frequented operation. If you really want to have the new value at the old position you need to run an \noptimize\n operation passing in a compare function to sort all lists accordingly.\n\n\n Why is there no sort method for the list associated with a key?\n\n\n A sort method would be possible from an implementation point of view, but as a list grows the cost of calling this method increases as well. Users that are not aware about the complexity might trigger it carelessly too often, e.g. after every single replace operation, finally slowing down the entire system.\n\n\n Can I use Multimap as a 1:1 key value store?\n\n\n Multimap can be used as a 1:1 key-value store, although other libraries may be better suited for this purpose. As always, you should pick the library that best fits your needs, both with respect to features and performance. When using Multimap as a 1:1 key-value store, you should set the block size as small as possible to waste as little space as possible, because each block will only contain just one value.", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/#how-it-works", 
            "text": "Multimap is implemented as an in-memory hash table which maps each key to a list of values. Keys and values are arbitrary byte arrays. The following schema illustrates the general design:  a  -  1, 2, 3, 4, 5, 6 b  -  7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 c  -  18, 19, 20, 21, 22, 23, 24  Putting a key-value pair into the map adds the value to the end of the list associated with the key. If no such list already exists it will be created. Looking up the key returns a read-only iterator to this list. If the key does not exist or the associated list is empty, the iterator is empty, i.e. it won't yield any value.   Removing a value from a list means to mark it as deleted, so that iterators will ignore such values. Removed values will remain on disk until an  optimize  operation has been run.  Replacing a value is implemented in terms of removing the old value followed by putting the new value. As a consequence, the new value always appears at the end of the list. Values that have been replaced also remain on disk and can only be deleted physically by running an  optimize  operation. The same is true to bring the values in certain order back again after performing replace operations.", 
            "title": "How It Works"
        }, 
        {
            "location": "/overview/#block-organization", 
            "text": "An important aspect of Multimap's design is that all lists are organized in blocks of data. The size of these blocks is fixed and can be chosen when a new instance is created. Typical block sizes in number of bytes are 64, 128, 256, 512, 1024, or even larger, and yes, it has to be a power of two. The schema, therefore, could be updated as follows:  a  -  [1, 2, 3], [4, 5, 6] b  -  [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, free] c  -  [18, 19, 20], [21, 22, 23], [24, free]  At runtime only the last block of each list is held in memory used as a write buffer. Preceding blocks are written to disk as soon as they are filled up, replaced by an id for later referencing. A single value might span multiple blocks if it does not fit into the last one. The schema now shows the structure that actually remains in memory.  a  -  b1, [4, 5, 6] b  -  b2, b3, b4, [16, 17, free] c  -  b5, b6, [24, free]  Hence, the total memory consumption of a map depends on   the number and size of keys  the number of block ids which is proportional to the number of values  the block size, because unless the list is empty its last block is always allocated   To estimate the memory footprint the following equation can be used:  mem_total = 1.5 * (mem_keys + mem_block_ids + mem_last_blocks)\n          = 1.5 * (num_keys * (avg_key_size + block_size) + (num_blocks * 3.1))  where  mem_keys        = num_keys * avg_key_size\nmem_block_ids   = num_blocks * 3.1\nmem_last_blocks = num_keys * block_size\nnum_blocks      = (num_values * avg_value_size) / block_size  Assuming a key set consisting of words from an English dictionary with an average key size of 5 bytes, the factor that has the biggest impact on the total memory footprint is the block size. Therefore, it is important to choose a value that is most suitable for the given use case to prevent running out of memory.  Large block sizes can improve I/O performance since more data is transferred at once. In contrast, large block sizes lead to higher memory consumption at runtime. As a rule of thumb, if a key set is small a larger block size should be chosen and vice versa. Of course, what is small and what is large depends on the given hardware. Try to make estimates and test different settings.  Here are a some examples:     num_keys  avg_key_size  num_blocks  block_size  memory      1 000 000  5 bytes  100 000 000  512 bytes  1.12 GiB    2 000 000  5 bytes  100 000 000  512 bytes  1.77 GiB    2 000 000  10 bytes  100 000 000  512 bytes  1.77 GiB    2 000 000  10 bytes  200 000 000  512 bytes  2.22 GiB    2 000 000  10 bytes  200 000 000  1024 bytes  3.68 GiB    10 000 000  10 bytes  1 000 000 000  64 bytes  6.19 GiB    10 000 000  10 bytes  1 000 000 000  128 bytes  6.87 GiB", 
            "title": "Block Organization"
        }, 
        {
            "location": "/overview/#serialization", 
            "text": "As mentioned previously, keys and values are arbitrary byte arrays. This has the advantage that Multimap does not need to deal with packing/unpacking of user-defined data types and leaves the door open for compression (currently not applied). For the user this has the advantage that he/she can stick with his/her preferred serialization method.  On the other hand, this approach has the disadvantage that values are seen as  binary large objects  with no type information. In other words, a value is treated as one entity and therefore can only be deleted or replaced as a whole. Updates on individual fields of composite types are not possible.   For more information please refer to Wikipedia's  comparison of data serialization formats .", 
            "title": "Serialization"
        }, 
        {
            "location": "/overview/#command-line-tool", 
            "text": "Multimap also comes with a command line tool that can and should be installed in addition to the shared library. The tool allows you to perform some administration operations right in your terminal. Here is the help page:  $ multimap help\nUSAGE\n\n  multimap COMMAND PATH_TO_MAP [PATH] [OPTIONS]\n\nCOMMANDS\n\n  help           Print this help message and exit.\n  stats          Print statistics about an instance.\n  import         Import key-value pairs from Base64-encoded text files.\n  export         Export key-value pairs to a Base64-encoded text file.\n  optimize       Rewrite an instance performing various optimizations.\n\nOPTIONS\n\n  --create       Create a new instance if missing when importing data.\n  --bs      NUM  Block size to use for a new instance. Default is 512.\n  --nparts  NUM  Number of partitions to use for a new instance. Default is 23.\n  --quiet        Don't print out any status messages.\n\nEXAMPLES\n\n  multimap stats    path/to/map\n  multimap import   path/to/map path/to/input\n  multimap import   path/to/map path/to/input/base64.csv\n  multimap import   path/to/map path/to/input/base64.csv --create\n  multimap export   path/to/map path/to/output/base64.csv\n  multimap optimize path/to/map path/to/output\n  multimap optimize path/to/map path/to/output --bs 128\n  multimap optimize path/to/map path/to/output --nparts 42\n  multimap optimize path/to/map path/to/output --nparts 42 --bs 128\n\n\nCopyright (C) 2015-2016 Martin Trenkmann http://multimap.io", 
            "title": "Command Line Tool"
        }, 
        {
            "location": "/overview/#multimap-stats", 
            "text": "This command reports statistical information about a map located in a given directory. A typical output reads as follows:  $ multimap stats path/to/map\n#0   block_size        128       ******************************\n#0   key_size_avg      8         ******************************\n#0   key_size_max      40        ******************************\n#0   key_size_min      1         ******************************\n#0   list_size_avg     45        *******************\n#0   list_size_max     974136    ****\n#0   list_size_min     1         ******************************\n#0   num_blocks        3170842   ******************\n#0   num_keys_total    573308    ******************************\n#0   num_keys_valid    573308    ******************************\n#0   num_values_total  25836927  *******************\n#0   num_values_valid  25836927  *******************\n\n#1   block_size        128       ******************************\n#1   key_size_avg      8         ******************************\n#1   key_size_max      40        ******************************\n#1   key_size_min      1         ******************************\n#1   list_size_avg     45        *******************\n#1   list_size_max     1010385   ****\n#1   list_size_min     1         ******************************\n#1   num_blocks        3209400   *******************\n#1   num_keys_total    572406    ******************************\n#1   num_keys_valid    572406    ******************************\n#1   num_values_total  26124736  *******************\n#1   num_values_valid  26124736  *******************\n\n[ #2 .. #22 ]\n\n===  block_size        128      \n===  key_size_avg      8        \n===  key_size_max      40       \n===  key_size_min      1        \n===  list_size_avg     47       \n===  list_size_max     8259736  \n===  list_size_min     1        \n===  num_blocks        77641183 \n===  num_keys_total    13167247 \n===  num_keys_valid    13167247 \n===  num_values_total  629686802\n===  num_values_valid  629686802\n===  num_partitions    23  Since a map is divided into several partitions there is one info block per partition, followed by a final block that states the total numbers. The asterisks visualize the numbers as relative values with respect to the partition with the maximum value in this category. The output can be filtered with a little help from  grep . For example, a histogram that shows the distribution of values among the partitions can be generated like this:  $ multimap stats path/to/map | grep values_total\n#0   num_values_total  25836927  *******************\n#1   num_values_total  26124736  *******************\n#2   num_values_total  25616082  *******************\n#3   num_values_total  24602683  ******************\n#4   num_values_total  23633504  *****************\n#5   num_values_total  25757280  *******************\n#6   num_values_total  24665881  ******************\n#7   num_values_total  24207863  ******************\n#8   num_values_total  36033742  **************************\n#9   num_values_total  27674578  ********************\n#10  num_values_total  41774200  ******************************\n#11  num_values_total  27141930  ********************\n#12  num_values_total  27015011  ********************\n#13  num_values_total  25249784  *******************\n#14  num_values_total  26979204  ********************\n#15  num_values_total  25433887  *******************\n#16  num_values_total  25533309  *******************\n#17  num_values_total  23607578  *****************\n#18  num_values_total  23853340  ******************\n#19  num_values_total  26713848  ********************\n#20  num_values_total  25827632  *******************\n#21  num_values_total  24587953  ******************\n#22  num_values_total  41815850  ******************************\n===  num_values_total  629686802  Similarly, to print only the total values you can run:  $ multimap stats path/to/map | grep =\n===  block_size        128      \n===  key_size_avg      8        \n===  key_size_max      40       \n===  key_size_min      1        \n===  list_size_avg     47       \n===  list_size_max     8259736  \n===  list_size_min     1        \n===  num_blocks        77641183 \n===  num_keys_total    13167247 \n===  num_keys_valid    13167247 \n===  num_values_total  629686802\n===  num_values_valid  629686802\n===  num_partitions    23", 
            "title": "$ multimap stats"
        }, 
        {
            "location": "/overview/#multimap-import", 
            "text": "This command allows you to import key-value pairs from Base64-encoded text files. The file format is defined as follows:   The file is in  CSV format .  The delimiter is whitespace or tab.  Each line starts with a key followed by one or more values.  Multiple lines may start with the same key.  Keys and values are encoded in Base64.   Example (not in Base64 for demonstration purposes):  key1 value1\nkey2 value2 value3\nkey1 value4\nkey3 value5 value6 value7 value8\nkey2 value9  is equivalent to:  key1 value1 value4\nkey2 value2 value3 value9\nkey3 value5 value6 value7 value8  is equivalent to:  key1 value1\nkey1 value4\nkey2 value2\nkey2 value3\nkey2 value9\nkey3 value5\nkey3 value6\nkey3 value7\nkey3 value8  The second listing is in canonical form, which means that all values sharing the same key are in one line. In other words, in a file that is in canonical form, there are no two lines that begin with the same key.", 
            "title": "$ multimap import"
        }, 
        {
            "location": "/overview/#multimap-export", 
            "text": "This command allows you to export all key-value pairs from a map into a single text file. The format of this file follows the description given in the  previous section . The generated file is in canonical form. This feature is useful for data exchange to other libraries and frameworks, or for backup purposes.", 
            "title": "$ multimap export"
        }, 
        {
            "location": "/overview/#multimap-optimize", 
            "text": "The optimize operation rewrites the entire map performing the following tasks:   Defragmentation. All blocks which belong to the same list are written sequentially to disk which improves locality and leads to better read performance.  Garbage collection. Values that are marked as deleted won't be copied which reduces the size of the new map and also improves locality.   In addition, some optional settings can be applied:   New block size. Changing the block size could be necessary to tweak the memory footprint.  List sorting. All lists can be sorted applying a user-defined compare function. This option is only available when using the  C++  and  Java API  directly.", 
            "title": "$ multimap optimize"
        }, 
        {
            "location": "/overview/#qa", 
            "text": "Why are all keys held in memory?   Multimap is designed for relatively small keys like dictionary words. Therefore, the footprint of the entire key set is rather small compared to all in-memory blocks that are used as write buffers. Furthermore, the library aims to run on server machines which tend to have more and more memory available. And of course, an internal hash table is a lot faster and easier to maintain than a partly externalized B+ tree or something similar.   Why both keys and values have to be byte arrays?   Multimap aims to keep things simple. There are plenty of very good  serialization libraries  available so that users can freely choose their preferred method. Reading and writing raw binary data also makes Multimap independent from such libraries which in turn facilitates data exchange with different programming languages and/or systems. On the other hand, due to lack of type information Multimap cannot operate on individual fields of composite types without injecting code for packing/unpacking.   Why values cannot be replaced in-place?   Values are written to disk in the same order as they were put without leaving any gaps. Therefore, if a new value is larger than the old one there is simply not enough room for it. An in-place replacement would be possible, though, if the value size is fixed. Maybe this option will be provided in further releases. Anyway, replacing values is considered a little-frequented operation. If you really want to have the new value at the old position you need to run an  optimize  operation passing in a compare function to sort all lists accordingly.   Why is there no sort method for the list associated with a key?   A sort method would be possible from an implementation point of view, but as a list grows the cost of calling this method increases as well. Users that are not aware about the complexity might trigger it carelessly too often, e.g. after every single replace operation, finally slowing down the entire system.   Can I use Multimap as a 1:1 key value store?   Multimap can be used as a 1:1 key-value store, although other libraries may be better suited for this purpose. As always, you should pick the library that best fits your needs, both with respect to features and performance. When using Multimap as a 1:1 key-value store, you should set the block size as small as possible to waste as little space as possible, because each block will only contain just one value.", 
            "title": "Q&amp;A"
        }, 
        {
            "location": "/cppbasics/", 
            "text": "#include \nmultimap/Map.hpp\n\n\n\n\n\nCreating a Map\n\n\nThe minimal code to create a map is\n\n\nmultimap::Options options;\noptions.create_if_missing = true;\nmultimap::Map map(\npath/to/directory\n, options);\n\n\n\n\nHowever, since a Map object is neither copyable nor moveable you might allocate it on the heap to be able to transfer ownership. In case of an error the constructor of Map also throws an exception that should be caught. So you would better write code like this:\n\n\nstd::unique_ptr\nmultimap::Map\n map;\ntry {\n  multimap::Options options;\n  options.create_if_missing = true;\n  map.reset(new Map(\npath/to/directory\n, options));\n} catch (std::runtime_error\n error) {\n  handleError(error);\n}\n\n\n\n\nOpening a Map\n\n\nTo open an already existing map with default options you can simply omit the options parameter.\n\n\nstd::unique_ptr\nmultimap::Map\n map;\ntry {\n  map.reset(new Map(\npath/to/directory\n));\n} catch (std::runtime_error\n error) {\n  handleError(error);\n}\n\n\n\n\nIf the map does not exist, an exception will be thrown.\n\n\nClosing a Map\n\n\nA map is closed automatically when its destructor is called. There is no explicit close method. If you really want to force destruction you can reset the smart pointer.\n\n\nmap.reset();\n\n\n\n\nPutting Values\n\n\nPutting a value means to append a value to the end of the list that is associated with a key. Both the key and the value are of type \nBytes\n which can be constructed implicitly from\n\n\n\n\na null-terminated \nconst char*\n,\n\n\na \nstd::string\n,\n\n\n\n\nor explicitly by a \nconst void*\n to raw data and its size.\n\n\nconst multimap::Bytes key = \nkey\n;\n\nmap-\nput(key, \nvalue\n);\n// Puts a value implicitly constructed from a null-terminated C-string.\n\nmap-\nput(key, std::to_string(23));\n// Puts a value implicitly constructed from a standard string.\n\nmap-\nput(key, multimap::Bytes(\nsome_pod, sizeof some_pod));\n// Puts a value explicitly constructed from a pointer to data and its size.\n// Note that PODs might cover more bytes than expected due to alignment.\n\n\n\n\nIt is important to mention that a Bytes object is always just a pointer/size wrapper without any ownership semantics. The actual lifetime of the wrapped data must be managed by the user and must outlive the lifetime of the Bytes object.\n\n\nGetting Values\n\n\nGetting values means to request a read-only \nIterator\n to the list associated with a key. If no such list exists the returned iterator points to an empty list. An iterator that points to a non-empty list holds a \nreader lock\n on this list to synchronize concurrent access. A list can be read by multiple iterators from different threads at the same time. The lock is released automatically when the iterator's lifetime ends.\n\n\n{\n  multimap::Map::Iterator iter = map-\nget(key);\n  // You could also have used 'auto' here.\n\n  while (iter.hasNext()) {\n    const multimap::Bytes value = iter.next();\n    // You could also have used 'auto' here.\n    // `value` points to data managed by the iterator,\n    // and which is valid until the next call to `next`.\n\n    doSomething(value);\n\n    std::cout \n value.toString() \n '\\n';\n    // Printing makes sense only if `value`\n    // actually contains printable characters.\n  }\n} // iter gets destroyed and the internal reader lock is released.\n\n\n\n\nThings about iterators that are also worth noting:\n\n\n\n\nIterators are movable and thus can be put into containers or the like. When doing so you have to take special care not to run into deadlocks, because\n\n\nthere is another type of iterator which holds a writer lock on a list for exclusive access. This type of iterator is only used internally for implementing remove and replace operations.\n\n\nIterators support lazy initialization which means that no I/O operation is performed until its \nnext()\n method has been called. This feature is useful in cases where multiple iterators must be requested first in order to determine in which order they have to be processed.\n\n\nCalling \nnext()\n followed by \ntoString()\n is a simple way to get a deep copy of the current value.\n\n\nIterators can tell the number of values left to iterate by invoking \navailable()\n.\n\n\n\n\nRemoving Values\n\n\nValues can be removed from a list by injecting a \nPredicate\n which yields true for values to be removed. There are methods to remove only the first or all matches from a list. Since this is a mutating operation the methods require exclusive access to the list and therefore try to acquire a \nwriter lock\n for that list.\n\n\n#include \nmultimap/callables.hpp\n\n\nmap-\nput(key, \n1\n);\nmap-\nput(key, \n2\n);\nmap-\nput(key, \n3\n);\nmap-\nput(key, \n4\n);\nmap-\nput(key, \n5\n);\nmap-\nput(key, \n6\n);\n\nmap-\nremoveValue(key, multimap::Equal(\n3\n));\n// Removes the first value equal to \n3\n.\n// key -\n {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}\n\nconst auto is_even = [](const multimap::Bytes\n value) {\n  return std::stoi(value.toString()) % 2 == 0;\n}\n\nmap-\nremoveValue(key, is_even);\n// Removes the first value that is even.\n// key -\n {\n1\n, \n4\n, \n5\n, \n6\n}\n\nmap-\nremoveValues(key, is_even);\n// Removes all values that are even.\n// key -\n {\n1\n, \n5\n}\n\nmap-\nremoveKey(key);\n// Removes all values.\n// key -\n {}\n\n\n\n\nWhen a value is removed it will only be marked as removed for the moment so that subsequent iterations will ignore it. Only an optimize operation triggered either via \nAPI call\n or the \ncommand line tool\n will remove the data physically.\n\n\nNote that if the list is already locked either by a \nreader\n or \nwriter lock\n any remove operation on that list will block until the lock is released. A thread should never try to remove values while holding iterators to the same list to avoid deadlocks.\n\n\nReplacing Values\n\n\nValues can be replaced by injecting a \nProcedure\n that represents a map function which yields a non-empty string for values to be replaced. There are methods to replace only the first or all matches in a list. Since this is a mutating operation the methods require exclusive access to the list and therefore try to acquire a \nwriter lock\n for that list.\n\n\nWhen a value is replaced the old value is marked as removed and the new value is appended to the end of the list. Hence, replace operations will not preserve the order of values. If a certain order needs to be restored an \noptimize\n operation has to be run parameterized with an appropriate \nCompare\n function.\n\n\n#include \nmultimap/callables.hpp\n\n\nmap-\nput(key, \n1\n);\nmap-\nput(key, \n2\n);\nmap-\nput(key, \n3\n);\nmap-\nput(key, \n4\n);\nmap-\nput(key, \n5\n);\nmap-\nput(key, \n6\n);\n\nmap-\nreplaceValue(key, \n3\n, \n4\n);\n// Replaces the first value equal to \n3\n by \n4\n.\n// key -\n {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n, \n4\n}\n\nconst auto increment_if_even = [](const multimap::Bytes\n value) {\n  const auto number = std::stoi(value.toString());\n  return (number % 2 == 0) ? std::to_string(number + 1) : \n;\n};\n\nmap-\nreplaceValue(key, increment_if_even);\n// Replaces the first value that is even by its successor.\n// key -\n {\n1\n, \n4\n, \n5\n, \n6\n, \n4\n, \n3\n}\n\nmap-\nreplaceValues(key, \n4\n, \n8\n);\n// Replaces all values equal to \n4\n by \n8\n.\n// key -\n {\n1\n, \n5\n, \n6\n, \n3\n, \n8\n, \n8\n}\n\nmap-\nreplaceValues(key, increment_if_even);\n// Replaces all values that are even by its successor.\n// key -\n {\n1\n, \n5\n, \n3\n, \n7\n, \n9\n, \n9\n}\n\n\n\n\nNote that if the list is already locked either by a \nreader\n or \nwriter lock\n any replace method will block until the lock is released. A thread should never try to replace values while holding iterators to the same list to avoid deadlocks.", 
            "title": "Basics"
        }, 
        {
            "location": "/cppbasics/#creating-a-map", 
            "text": "The minimal code to create a map is  multimap::Options options;\noptions.create_if_missing = true;\nmultimap::Map map( path/to/directory , options);  However, since a Map object is neither copyable nor moveable you might allocate it on the heap to be able to transfer ownership. In case of an error the constructor of Map also throws an exception that should be caught. So you would better write code like this:  std::unique_ptr multimap::Map  map;\ntry {\n  multimap::Options options;\n  options.create_if_missing = true;\n  map.reset(new Map( path/to/directory , options));\n} catch (std::runtime_error  error) {\n  handleError(error);\n}", 
            "title": "Creating a Map"
        }, 
        {
            "location": "/cppbasics/#opening-a-map", 
            "text": "To open an already existing map with default options you can simply omit the options parameter.  std::unique_ptr multimap::Map  map;\ntry {\n  map.reset(new Map( path/to/directory ));\n} catch (std::runtime_error  error) {\n  handleError(error);\n}  If the map does not exist, an exception will be thrown.", 
            "title": "Opening a Map"
        }, 
        {
            "location": "/cppbasics/#closing-a-map", 
            "text": "A map is closed automatically when its destructor is called. There is no explicit close method. If you really want to force destruction you can reset the smart pointer.  map.reset();", 
            "title": "Closing a Map"
        }, 
        {
            "location": "/cppbasics/#putting-values", 
            "text": "Putting a value means to append a value to the end of the list that is associated with a key. Both the key and the value are of type  Bytes  which can be constructed implicitly from   a null-terminated  const char* ,  a  std::string ,   or explicitly by a  const void*  to raw data and its size.  const multimap::Bytes key =  key ;\n\nmap- put(key,  value );\n// Puts a value implicitly constructed from a null-terminated C-string.\n\nmap- put(key, std::to_string(23));\n// Puts a value implicitly constructed from a standard string.\n\nmap- put(key, multimap::Bytes( some_pod, sizeof some_pod));\n// Puts a value explicitly constructed from a pointer to data and its size.\n// Note that PODs might cover more bytes than expected due to alignment.  It is important to mention that a Bytes object is always just a pointer/size wrapper without any ownership semantics. The actual lifetime of the wrapped data must be managed by the user and must outlive the lifetime of the Bytes object.", 
            "title": "Putting Values"
        }, 
        {
            "location": "/cppbasics/#getting-values", 
            "text": "Getting values means to request a read-only  Iterator  to the list associated with a key. If no such list exists the returned iterator points to an empty list. An iterator that points to a non-empty list holds a  reader lock  on this list to synchronize concurrent access. A list can be read by multiple iterators from different threads at the same time. The lock is released automatically when the iterator's lifetime ends.  {\n  multimap::Map::Iterator iter = map- get(key);\n  // You could also have used 'auto' here.\n\n  while (iter.hasNext()) {\n    const multimap::Bytes value = iter.next();\n    // You could also have used 'auto' here.\n    // `value` points to data managed by the iterator,\n    // and which is valid until the next call to `next`.\n\n    doSomething(value);\n\n    std::cout   value.toString()   '\\n';\n    // Printing makes sense only if `value`\n    // actually contains printable characters.\n  }\n} // iter gets destroyed and the internal reader lock is released.  Things about iterators that are also worth noting:   Iterators are movable and thus can be put into containers or the like. When doing so you have to take special care not to run into deadlocks, because  there is another type of iterator which holds a writer lock on a list for exclusive access. This type of iterator is only used internally for implementing remove and replace operations.  Iterators support lazy initialization which means that no I/O operation is performed until its  next()  method has been called. This feature is useful in cases where multiple iterators must be requested first in order to determine in which order they have to be processed.  Calling  next()  followed by  toString()  is a simple way to get a deep copy of the current value.  Iterators can tell the number of values left to iterate by invoking  available() .", 
            "title": "Getting Values"
        }, 
        {
            "location": "/cppbasics/#removing-values", 
            "text": "Values can be removed from a list by injecting a  Predicate  which yields true for values to be removed. There are methods to remove only the first or all matches from a list. Since this is a mutating operation the methods require exclusive access to the list and therefore try to acquire a  writer lock  for that list.  #include  multimap/callables.hpp \n\nmap- put(key,  1 );\nmap- put(key,  2 );\nmap- put(key,  3 );\nmap- put(key,  4 );\nmap- put(key,  5 );\nmap- put(key,  6 );\n\nmap- removeValue(key, multimap::Equal( 3 ));\n// Removes the first value equal to  3 .\n// key -  { 1 ,  2 ,  4 ,  5 ,  6 }\n\nconst auto is_even = [](const multimap::Bytes  value) {\n  return std::stoi(value.toString()) % 2 == 0;\n}\n\nmap- removeValue(key, is_even);\n// Removes the first value that is even.\n// key -  { 1 ,  4 ,  5 ,  6 }\n\nmap- removeValues(key, is_even);\n// Removes all values that are even.\n// key -  { 1 ,  5 }\n\nmap- removeKey(key);\n// Removes all values.\n// key -  {}  When a value is removed it will only be marked as removed for the moment so that subsequent iterations will ignore it. Only an optimize operation triggered either via  API call  or the  command line tool  will remove the data physically.  Note that if the list is already locked either by a  reader  or  writer lock  any remove operation on that list will block until the lock is released. A thread should never try to remove values while holding iterators to the same list to avoid deadlocks.", 
            "title": "Removing Values"
        }, 
        {
            "location": "/cppbasics/#replacing-values", 
            "text": "Values can be replaced by injecting a  Procedure  that represents a map function which yields a non-empty string for values to be replaced. There are methods to replace only the first or all matches in a list. Since this is a mutating operation the methods require exclusive access to the list and therefore try to acquire a  writer lock  for that list.  When a value is replaced the old value is marked as removed and the new value is appended to the end of the list. Hence, replace operations will not preserve the order of values. If a certain order needs to be restored an  optimize  operation has to be run parameterized with an appropriate  Compare  function.  #include  multimap/callables.hpp \n\nmap- put(key,  1 );\nmap- put(key,  2 );\nmap- put(key,  3 );\nmap- put(key,  4 );\nmap- put(key,  5 );\nmap- put(key,  6 );\n\nmap- replaceValue(key,  3 ,  4 );\n// Replaces the first value equal to  3  by  4 .\n// key -  { 1 ,  2 ,  4 ,  5 ,  6 ,  4 }\n\nconst auto increment_if_even = [](const multimap::Bytes  value) {\n  const auto number = std::stoi(value.toString());\n  return (number % 2 == 0) ? std::to_string(number + 1) :  ;\n};\n\nmap- replaceValue(key, increment_if_even);\n// Replaces the first value that is even by its successor.\n// key -  { 1 ,  4 ,  5 ,  6 ,  4 ,  3 }\n\nmap- replaceValues(key,  4 ,  8 );\n// Replaces all values equal to  4  by  8 .\n// key -  { 1 ,  5 ,  6 ,  3 ,  8 ,  8 }\n\nmap- replaceValues(key, increment_if_even);\n// Replaces all values that are even by its successor.\n// key -  { 1 ,  5 ,  3 ,  7 ,  9 ,  9 }  Note that if the list is already locked either by a  reader  or  writer lock  any replace method will block until the lock is released. A thread should never try to replace values while holding iterators to the same list to avoid deadlocks.", 
            "title": "Replacing Values"
        }, 
        {
            "location": "/javabasics/", 
            "text": "import io.multimap.Iterator;\nimport io.multimap.Map;\nimport io.multimap.Options;\n\n\n\n\nCreating a Map\n\n\nThe minimal code to create a map is\n\n\nOptions options = new Options();\noptions.setCreateIfMissing(true);\nMap map = new Map(\npath/to/directory\n, options);\n\n\n\n\nHowever, you should also catch errors that may occur during construction.\n\n\nMap map = null;\ntry {\n  Options options = new Options();\n  options.setCreateIfMissing(true);\n  map = new Map(\npath/to/directory\n, options);\n} catch (Exception e) {\n  handleError(e);\n}\n\n\n\n\nOpening a Map\n\n\nTo open an already existing map with default options you can simply omit the options parameter.\n\n\nMap map = null;\ntry {\n  map = new Map(\npath/to/directory\n);\n} catch (Exception e) {\n  handleError(e);\n}\n\n\n\n\nIf the map does not exist, an exception will be thrown.\n\n\nClosing a Map\n\n\nA map must be explicitly closed by calling its \nclose()\n method in order to flush all data to disk and to ensure that the map is stored in consistent state. Not closing a map will cause data loss.\n\n\nmap.close();  // Never forget.\n\n\n\n\nPutting Values\n\n\nPutting a value means to append a value to the end of the list that is associated with a key. Both the key and the value are of type \nbyte[]\n.\n\n\nCharset cs = Charset.forName(\nUTF-8\n);\n\nbyte[] key = \nkey\n.getBytes(cs);\n\nmap.put(key, \nvalue\n.getBytes(cs));\n// Puts a value constructed from a string.\n\nmap.put(key, Integer.toString(23).getBytes(cs));\n// Puts a value constructed from an integer.\n\nmap.put(key, ByteBuffer.allocate(4).putInt(23).array());\n// Puts a value constructed from a java.nio.ByteBuffer.\n\nmap.put(key, somelib.serializeAsByteArray(someObject));\n// Puts a value packed by some serialization library.\n\n\n\n\nGetting Values\n\n\nGetting values means to request a read-only \nIterator\n to the list associated with a key. If no such list exists the returned iterator points to an empty list. An iterator that points to a non-empty list holds a \nreader lock\n on this list to synchronize concurrent access. A list can be read by multiple iterators from different threads at the same time. If an iterator is not needed anymore its \nclose()\n method must be called in order to unlock the underlying list.\n\n\nIterator iter = map.get(key);\n\nwhile (iter.hasNext()) {\n  ByteBuffer value = iter.next();\n  doSomething(value);\n}\n\niter.close();  // Releases the internal reader lock.\n\n\n\n\nA call to \nnext()\n returns the next value as an \njava.nio.ByteBuffer\n. This byte buffer is a direct one, which means that it wraps a pointer to memory allocated and managed by the native library. It is not backed by a \nbyte[]\n managed by the Java Garbage Collector. Hence, the value is only valid as long as the iterator is not moving forward. You should never copy around this kind of byte buffer.\n\n\nThings about iterators that are also worth noting:\n\n\n\n\nSince iterators can be put into containers or the like, there has to take special care not to run into deadlocks, because there is another type of iterator which holds a writer lock on a list for exclusive access. This type of iterator is only used internally for implementing remove and replace operations.\n\n\nIterators support lazy initialization which means that no I/O operation is performed until its \nnext()\n method has been called. This feature is useful in cases where multiple iterators must be requested first in order to determine in which order they have to be processed.\n\n\nCalling \nnextAsByteArray()\n instead of \nnext()\n is a simple way to get a deep copy of the current value as a newly allocated \nbyte[]\n that is managed by the Java Garbage Collector.\n\n\nIterators can tell the number of values left to iterate by invoking \navailable()\n.\n\n\n\n\nRemoving Values\n\n\nValues can be removed from a list by injecting a \nPredicate\n which yields true for values to be removed. There are methods to remove only the first or all matches from a list. Since this is a mutating operation the methods require exclusive access to the list and therefore try to acquire a \nwriter lock\n for that list.\n\n\nimport io.multimap.Callables;\n\nmap.put(key, \n1\n.getBytes(cs));\nmap.put(key, \n2\n.getBytes(cs));\nmap.put(key, \n3\n.getBytes(cs));\nmap.put(key, \n4\n.getBytes(cs));\nmap.put(key, \n5\n.getBytes(cs));\nmap.put(key, \n6\n.getBytes(cs));\n\nmap.removeValue(key, \n3\n.getBytes(cs));\n// Removes the first value equal to \n3\n.\n// key -\n {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n}\n\nPredicate isEven = new Predicate() {  \n  @Override\n  protected boolean callOnReadOnly(ByteBuffer value) {\n    return Integer.parseInt(Util.toString(value, cs)) % 2 == 0;\n  }\n};\n\nmap.removeValue(key, isEven);\n// Removes the first value that is even.\n// key -\n {\n1\n, \n4\n, \n5\n, \n6\n}\n\nmap.removeValues(key, isEven);\n// Removes all values that are even.\n// key -\n {\n1\n, \n5\n}\n\nmap.removeKey(key);\n// Removes all values.\n// key -\n {}\n\n\n\n\nWhen a value is removed it will only be marked as removed for the moment so that subsequent iterations will ignore it. Only an optimize operation triggered either via \nAPI call\n or the \ncommand line tool\n will remove the data physically.\n\n\nNote that if the list is already locked either by a \nreader\n or \nwriter lock\n any remove operation on that list will block until the lock is released. A thread should never try to remove values while holding iterators to the same list to avoid deadlocks.\n\n\nReplacing Values\n\n\nValues can be replaced by injecting a \nProcedure\n that represents a map function which yields a \nbyte[]\n for values to be replaced or \nnull\n if not. There are methods to replace only the first or all matches in a list. Since this is a mutating operation the methods require exclusive access to the list and therefore try to acquire a \nwriter lock\n for that list.\n\n\nWhen a value is replaced the old value is marked as removed and the new value is appended to the end of the list. Hence, replace operations will not preserve the order of values. If a certain order needs to be restored an \noptimize\n operation has to be run parameterized with an appropriate \nLessThan\n function.\n\n\nimport io.multimap.Callables;\n\nmap.put(key, \n1\n.getBytes(cs));\nmap.put(key, \n2\n.getBytes(cs));\nmap.put(key, \n3\n.getBytes(cs));\nmap.put(key, \n4\n.getBytes(cs));\nmap.put(key, \n5\n.getBytes(cs));\nmap.put(key, \n6\n.getBytes(cs));\n\nmap.replaceValue(key, \n3\n.getBytes(cs), \n4\n.getBytes(cs));\n// Replaces the first value equal to \n3\n by \n4\n.\n// key -\n {\n1\n, \n2\n, \n4\n, \n5\n, \n6\n, \n4\n}\n\nFunction incrementIfEven = new Function() {  \n  @Override\n  protected byte[] callOnReadOnly(ByteBuffer value) {\n    int number = Integer.parseInt(Util.toString(value, cs));\n    return (number % 2 == 0) ? Integer.toString(number + 1).getBytes(cs) : null;\n  }\n};\n\nmap.replaceValue(key, incrementIfEven);\n// Replaces the first value that is even by its successor.\n// key -\n {\n1\n, \n4\n, \n5\n, \n6\n, \n4\n, \n3\n}\n\nmap.replaceValues(key, \n4\n.getBytes(cs), \n8\n.getBytes(cs));\n// Replaces all values equal to \n4\n by \n8\n.\n// key -\n {\n1\n, \n5\n, \n6\n, \n3\n, \n8\n, \n8\n}\n\nmap.replaceValues(key, incrementIfEven);\n// Replaces all values that are even by its successor.\n// key -\n {\n1\n, \n5\n, \n3\n, \n7\n, \n9\n, \n9\n}\n\n\n\n\nNote that if the list is already locked either by a \nreader\n or \nwriter lock\n any replace method will block until the lock is released. A thread should never try to replace values while holding iterators to the same list to avoid deadlocks.", 
            "title": "Basics"
        }, 
        {
            "location": "/javabasics/#creating-a-map", 
            "text": "The minimal code to create a map is  Options options = new Options();\noptions.setCreateIfMissing(true);\nMap map = new Map( path/to/directory , options);  However, you should also catch errors that may occur during construction.  Map map = null;\ntry {\n  Options options = new Options();\n  options.setCreateIfMissing(true);\n  map = new Map( path/to/directory , options);\n} catch (Exception e) {\n  handleError(e);\n}", 
            "title": "Creating a Map"
        }, 
        {
            "location": "/javabasics/#opening-a-map", 
            "text": "To open an already existing map with default options you can simply omit the options parameter.  Map map = null;\ntry {\n  map = new Map( path/to/directory );\n} catch (Exception e) {\n  handleError(e);\n}  If the map does not exist, an exception will be thrown.", 
            "title": "Opening a Map"
        }, 
        {
            "location": "/javabasics/#closing-a-map", 
            "text": "A map must be explicitly closed by calling its  close()  method in order to flush all data to disk and to ensure that the map is stored in consistent state. Not closing a map will cause data loss.  map.close();  // Never forget.", 
            "title": "Closing a Map"
        }, 
        {
            "location": "/javabasics/#putting-values", 
            "text": "Putting a value means to append a value to the end of the list that is associated with a key. Both the key and the value are of type  byte[] .  Charset cs = Charset.forName( UTF-8 );\n\nbyte[] key =  key .getBytes(cs);\n\nmap.put(key,  value .getBytes(cs));\n// Puts a value constructed from a string.\n\nmap.put(key, Integer.toString(23).getBytes(cs));\n// Puts a value constructed from an integer.\n\nmap.put(key, ByteBuffer.allocate(4).putInt(23).array());\n// Puts a value constructed from a java.nio.ByteBuffer.\n\nmap.put(key, somelib.serializeAsByteArray(someObject));\n// Puts a value packed by some serialization library.", 
            "title": "Putting Values"
        }, 
        {
            "location": "/javabasics/#getting-values", 
            "text": "Getting values means to request a read-only  Iterator  to the list associated with a key. If no such list exists the returned iterator points to an empty list. An iterator that points to a non-empty list holds a  reader lock  on this list to synchronize concurrent access. A list can be read by multiple iterators from different threads at the same time. If an iterator is not needed anymore its  close()  method must be called in order to unlock the underlying list.  Iterator iter = map.get(key);\n\nwhile (iter.hasNext()) {\n  ByteBuffer value = iter.next();\n  doSomething(value);\n}\n\niter.close();  // Releases the internal reader lock.  A call to  next()  returns the next value as an  java.nio.ByteBuffer . This byte buffer is a direct one, which means that it wraps a pointer to memory allocated and managed by the native library. It is not backed by a  byte[]  managed by the Java Garbage Collector. Hence, the value is only valid as long as the iterator is not moving forward. You should never copy around this kind of byte buffer.  Things about iterators that are also worth noting:   Since iterators can be put into containers or the like, there has to take special care not to run into deadlocks, because there is another type of iterator which holds a writer lock on a list for exclusive access. This type of iterator is only used internally for implementing remove and replace operations.  Iterators support lazy initialization which means that no I/O operation is performed until its  next()  method has been called. This feature is useful in cases where multiple iterators must be requested first in order to determine in which order they have to be processed.  Calling  nextAsByteArray()  instead of  next()  is a simple way to get a deep copy of the current value as a newly allocated  byte[]  that is managed by the Java Garbage Collector.  Iterators can tell the number of values left to iterate by invoking  available() .", 
            "title": "Getting Values"
        }, 
        {
            "location": "/javabasics/#removing-values", 
            "text": "Values can be removed from a list by injecting a  Predicate  which yields true for values to be removed. There are methods to remove only the first or all matches from a list. Since this is a mutating operation the methods require exclusive access to the list and therefore try to acquire a  writer lock  for that list.  import io.multimap.Callables;\n\nmap.put(key,  1 .getBytes(cs));\nmap.put(key,  2 .getBytes(cs));\nmap.put(key,  3 .getBytes(cs));\nmap.put(key,  4 .getBytes(cs));\nmap.put(key,  5 .getBytes(cs));\nmap.put(key,  6 .getBytes(cs));\n\nmap.removeValue(key,  3 .getBytes(cs));\n// Removes the first value equal to  3 .\n// key -  { 1 ,  2 ,  4 ,  5 ,  6 }\n\nPredicate isEven = new Predicate() {  \n  @Override\n  protected boolean callOnReadOnly(ByteBuffer value) {\n    return Integer.parseInt(Util.toString(value, cs)) % 2 == 0;\n  }\n};\n\nmap.removeValue(key, isEven);\n// Removes the first value that is even.\n// key -  { 1 ,  4 ,  5 ,  6 }\n\nmap.removeValues(key, isEven);\n// Removes all values that are even.\n// key -  { 1 ,  5 }\n\nmap.removeKey(key);\n// Removes all values.\n// key -  {}  When a value is removed it will only be marked as removed for the moment so that subsequent iterations will ignore it. Only an optimize operation triggered either via  API call  or the  command line tool  will remove the data physically.  Note that if the list is already locked either by a  reader  or  writer lock  any remove operation on that list will block until the lock is released. A thread should never try to remove values while holding iterators to the same list to avoid deadlocks.", 
            "title": "Removing Values"
        }, 
        {
            "location": "/javabasics/#replacing-values", 
            "text": "Values can be replaced by injecting a  Procedure  that represents a map function which yields a  byte[]  for values to be replaced or  null  if not. There are methods to replace only the first or all matches in a list. Since this is a mutating operation the methods require exclusive access to the list and therefore try to acquire a  writer lock  for that list.  When a value is replaced the old value is marked as removed and the new value is appended to the end of the list. Hence, replace operations will not preserve the order of values. If a certain order needs to be restored an  optimize  operation has to be run parameterized with an appropriate  LessThan  function.  import io.multimap.Callables;\n\nmap.put(key,  1 .getBytes(cs));\nmap.put(key,  2 .getBytes(cs));\nmap.put(key,  3 .getBytes(cs));\nmap.put(key,  4 .getBytes(cs));\nmap.put(key,  5 .getBytes(cs));\nmap.put(key,  6 .getBytes(cs));\n\nmap.replaceValue(key,  3 .getBytes(cs),  4 .getBytes(cs));\n// Replaces the first value equal to  3  by  4 .\n// key -  { 1 ,  2 ,  4 ,  5 ,  6 ,  4 }\n\nFunction incrementIfEven = new Function() {  \n  @Override\n  protected byte[] callOnReadOnly(ByteBuffer value) {\n    int number = Integer.parseInt(Util.toString(value, cs));\n    return (number % 2 == 0) ? Integer.toString(number + 1).getBytes(cs) : null;\n  }\n};\n\nmap.replaceValue(key, incrementIfEven);\n// Replaces the first value that is even by its successor.\n// key -  { 1 ,  4 ,  5 ,  6 ,  4 ,  3 }\n\nmap.replaceValues(key,  4 .getBytes(cs),  8 .getBytes(cs));\n// Replaces all values equal to  4  by  8 .\n// key -  { 1 ,  5 ,  6 ,  3 ,  8 ,  8 }\n\nmap.replaceValues(key, incrementIfEven);\n// Replaces all values that are even by its successor.\n// key -  { 1 ,  5 ,  3 ,  7 ,  9 ,  9 }  Note that if the list is already locked either by a  reader  or  writer lock  any replace method will block until the lock is released. A thread should never try to replace values while holding iterators to the same list to avoid deadlocks.", 
            "title": "Replacing Values"
        }, 
        {
            "location": "/cppreference/", 
            "text": "Bytes.hpp\n\n\n#include \nmultimap/Bytes.hpp\n\nnamespace multimap\n\n\n\n\nclass Bytes\n\n\nThis class is a thin wrapper for raw binary data. It just holds a pointer to data together with its size (number of bytes). It is used to represent keys and values that are put into or gotten from a map. An object of this class never deep copies the data it is constructed from, nor does it take any ownership of the data. It is really just a helper for providing a generic interface.\n\n\n\n\n\n \n\n  \nMember functions\n\n \n\n \n\n  \n\n  \n\n   \nBytes()\n\n   \nCreates an empty byte array. \nmore...\n\n  \n\n \n\n \n\n  \n\n  \n\n   \nBytes(const char * cstr)\n\n   \nCreates a byte array from a null-terminated C-string. \nmore...\n\n  \n\n \n\n \n\n  \n\n  \n\n   \nBytes(const std::string \n&\n str)\n\n   \nCreates a byte array from a standard string. \nmore...\n\n  \n\n \n\n \n\n  \n\n  \n\n   \nBytes(const void * data, size_t size)\n\n   \nCreates a byte array from arbitrary data. \nmore...\n\n  \n\n \n\n \n\n  \nconst char *\n\n  \n\n   \ndata() const\n\n   \nReturns a read-only pointer to the wrapped data.\n\n  \n\n \n\n \n\n  \nsize_t\n\n  \n\n   \nsize() const\n\n   \nReturns the number of bytes wrapped.\n\n  \n\n \n\n \n\n  \nconst char *\n\n  \n\n   \nbegin() const\n\n   \nReturns a read-only pointer to the beginning of the wrapped data.\n\n  \n\n \n\n \n\n  \nconst char *\n\n  \n\n   \nend() const\n\n   \nReturns a past-the-end pointer to the wrapped data.\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \nempty() const\n\n   \nTells whether the byte array is empty. \nmore...\n\n  \n\n \n\n \n\n  \nvoid\n\n  \n\n   \nclear()\n\n   \nLet this byte array point to an empty array. \nmore...\n\n  \n\n \n\n \n\n  \nstd::string\n\n  \n\n   \ntoString() const\n\n   \nReturns a string which contains a copy of the wrapped data. \nmore...\n\n  \n\n \n\n \n\n  \nNon-member functions\n\n \n\n \n\n  \nbool\n\n  \n\n   \noperator==(const Bytes \n&\n lhs, const Bytes \n&\n rhs)\n\n   \nCompares two byte arrays for equality. \nmore...\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \noperator!=(const Bytes \n&\n lhs, const Bytes \n&\n rhs)\n\n   \nReturns the inverse of the previous function.\n\n  \n\n \n\n \n\n  \nHelper classes\n\n \n\n \n\n  \n\n  \n\n   \nstd::hash\nBytes\n\n   \nHash support for class Bytes.\n\n  \n\n \n\n\n\n\n\n\n\n\n \nBytes::Bytes()\n\n \nCreates an empty byte array.\n\n \n\n \n\n  \ndata() != nullptr\n\n  \nsize() == 0\n\n \n\n\n\n\n\n\n \nBytes::Bytes(const char * cstr)\n\n \nCreates a byte array from a null-terminated C-string. This constructor allows implicit conversion.\n\n \n\n \n\n  \ndata() == cstr\n\n  \nsize() == std::strlen(cstr)\n\n \n\n\n\n\n\n\n \nBytes::Bytes(const std::string \n&\n str)\n\n \nCreates a byte array from a standard string. This constructor allows implicit conversion.\n\n \n\n \n\n  \ndata() == str.data()\n\n  \nsize() == str.size()\n\n \n\n\n\n\n\n\n \nBytes::Bytes(const void * data, size_t size)\n\n \nCreates a byte array from arbitrary data.\n\n \n\n \n\n  \ndata() == data\n\n  \nsize() == size\n\n \n\n\n\n\n\n\n \nbool Bytes::empty() const\n\n \nTells whether the byte array is empty. Returns \ntrue\n if the number of bytes is zero, \nfalse\n otherwise.\n\n\n\n\n\n\n \nvoid Bytes::clear()\n\n \nLet this byte array point to an empty array.\n\n \n\n \n\n  \ndata() != nullptr\n\n  \nsize() == 0\n\n \n\n\n\n\n\n\n \nstd::string toString() const\n\n \nReturns a string which contains a copy of the wrapped data. \nstd::string\n is used as a convenient byte buffer and may contain bytes that are not printable or even null-bytes.\n\n \n\n \n\n  \ndata() != return_value.data()\n\n  \nsize() == return_value.size()\n\n \n\n\n\n\n\n\n \nbool operator==(const Bytes \n&\n lhs, const Bytes \n&\n rhs)\n\n \nCompares two byte arrays for equality. Two byte arrays are equal, if they wrap the same number of bytes, and which are equal after byte-wise comparison.\n\n\n\n\n\ncallables.hpp\n\n\n#include \nmultimap/callables.hpp\n\nnamespace multimap\n\n\n\n\nThis file contains some convenient function objects implementing the \nPredicate\n interface.\n\n\nstruct Contains\n\n\nA function object that checks if a byte array contains another one in terms of a substring. Note that the empty byte array is a substring of any other byte array.\n\n\n\n\n\n \n\n  \nMember functions\n\n \n\n \n\n  \nexplicit\n\n  \n\n   \nContains(const Bytes \n&\n bytes)\n\n   \nCreates a functor that checks for containment of bytes when called.\n\n  \n\n \n\n \n\n  \nconst Bytes \n&\n\n  \n\n   \nbytes() const\n\n   \nReturns a read-only reference to the wrapped byte array.\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \noperator()(const Bytes \n&\n bytes) const\n\n   \nReturns true if bytes contains the wrapped byte array, false otherwise.\n\n  \n\n \n\n\n\n\n\n\n\nstruct StartsWith\n\n\nA function object that checks if a byte array has a certain prefix.\n\n\n\n\n\n \n\n  \nMember functions\n\n \n\n \n\n  \nexplicit\n\n  \n\n   \nStartsWith(const Bytes \n&\n bytes)\n\n   \nCreates a functor that checks if a byte array starts with bytes when called.\n\n  \n\n \n\n \n\n  \nconst Bytes \n&\n\n  \n\n   \nbytes() const\n\n   \nReturns a read-only reference to the wrapped byte array.\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \noperator()(const Bytes \n&\n bytes) const\n\n   \nReturns true if bytes starts with the wrapped byte array, false otherwise.\n\n  \n\n \n\n\n\n\n\n\n\nstruct EndsWith\n\n\nA function object that checks if a byte array has a certain suffix.\n\n\n\n\n\n \n\n  \nMember functions\n\n \n\n \n\n  \nexplicit\n\n  \n\n   \nEndsWith(const Bytes \n&\n bytes)\n\n   \nCreates a functor that checks if a byte array ends with bytes when called.\n\n  \n\n \n\n \n\n  \nconst Bytes \n&\n\n  \n\n   \nbytes() const\n\n   \nReturns a read-only reference to the wrapped byte array.\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \noperator()(const Bytes \n&\n bytes) const\n\n   \nReturns true if bytes ends with the wrapped byte array, false otherwise.\n\n  \n\n \n\n\n\n\n\n\n\nMap.hpp\n\n\n#include \nmultimap/Map.hpp\n\nnamespace multimap\n\n\n\n\nclass Map\n\n\nThis class implements a 1:n key-value store where each key is associated with a list of values. When putting a key-value pair into the map, the value is appended to the end of the list that is associated with the key. If no such key-list pair already exist, it will be created. Looking up a key returns a read-only iterator for the associated list. If the key does not exist, the list is considered to be empty and the returned iterator has no values to deliver. From a user's point of view there is no distinction between an empty list and a non-existing list.\n\n\nMap also supports removing or replacing values. When a value is removed, it will be marked as such for the moment making it invisible for subsequent iterations. Running an \noptimze\n operation removes the data physically. The replace operation is implemented as a remove of the old value followed by an insert/put of the new value. In other words, the replacement is not in-place, but the new value is always the last value in the corresponding list. To restore a certain order an \noptimze\n operation can be run as well. However, optimization is considered a less frequent, more administrative task.\n\n\nThe class is designed to be a fast and mutable 1:n key-value store. For that reason, Map holds the entire key set in memory. This is also true for keys that were removed from the map at runtime. In addition, each key is associated with a write buffer which altogether contribute a lot to the total memory footprint of the map. Therefore, the number of keys to be put is limited by the amount of available memory. However, this simple design was intended in favour of performance, especially due to the fact that memory is relatively cheap and (server) machines are equipped with more and more of it. As a rule of thumb, assuming keys with 10 bytes in size on average, Map scales up to 10 M keys on desktop machines with 8 GiB of RAM and up to 100 M keys on server machines with 64 GiB of RAM. The number of values, though, is practically limited only by the amount of disk space. For more information, please visit the \noverview\n page.\n\n\n\n\n\n \n\n  \nMember types\n\n \n\n \n\n  \n\n  \n\n   \nLimits\n\n   \nProvides static methods to ask for maximum key and value sizes. \nmore...\n\n  \n\n \n\n \n\n  \n\n  \n\n   \nStats\n\n   \nType that reports statistical information about an instance of Map. \nmore...\n\n  \n\n \n\n \n\n  \n\n  \n\n   \nIterator\n\n   \nInput iterator type that reads a list of values. \nmore...\n\n  \n\n \n\n \n\n  \nMember functions\n\n \n\n \n\n  \nexplicit\n\n  \n\n   \nMap(const boost::filesystem::path \n&\n directory)\n\n   \nOpens an already existing map located in directory. \nmore...\n\n  \n\n \n\n \n\n  \n\n  \n\n   \nMap(const boost::filesystem::path \n&\n directory,\n\n   \nnbsp(4)\nconst Options \n&\n options)\n\n   \nOpens or creates a map in directory. \nmore...\n\n  \n\n \n\n \n\n  \n\n  \n\n   \n~Map()\n\n   \nFlushes all buffered data to disk, closes the map, and unlocks the directory where the map is located.\n\n  \n\n \n\n \n\n  \nvoid\n\n  \n\n   \nput(const Bytes \n&\n key, const Bytes \n&\n value)\n\n   \nAppends value to the end of the list associated with key. \nmore...\n\n  \n\n \n\n \n\n  \nIterator\n\n  \n\n   \nget(const Bytes \n&\n key) const\n\n   \nReturns a read-only iterator for the list associated with key. \nmore...\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \nremoveKey(const Bytes \n&\n key)\n\n   \nRemoves all values associated with key. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \ntemplate\n\n    \nuint32_t\n\n  \n\n  \n\n   \ntypename Predicate\n\n   \nremoveKeys(Predicate predicate)\n\n   \nRemoves all values associated with keys for which predicate yields true. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \ntemplate\n\n    \nbool\n\n  \n\n  \n\n   \ntypename Predicate\n\n   \nremoveValue(const Bytes \n&\n key, Predicate predicate)\n\n   \nRemoves the first value from the list associated with key for which predicate yields true. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \ntemplate\n\n    \nuint32_t\n\n  \n\n  \n\n   \ntypename Predicate\n\n   \nremoveValues(const Bytes \n&\n key, Predicate predicate)\n\n   \nRemoves all values from the list associated with key for which predicate yields true. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \ntemplate\n\n    \nbool\n\n  \n\n  \n\n   \ntypename Function\n\n   \nreplaceValue(const Bytes \n&\n key, Function map)\n\n   \nReplaces the first value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \ntemplate\n\n    \nuint32_t\n\n  \n\n  \n\n   \ntypename Function\n\n   \nreplaceValues(const Bytes \n&\n key, Function map)\n\n   \nReplaces each value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced. \nmore...\n\n  \n\n \n\n \n\n  \nuint32_t\n\n  \n\n   \nreplaceValues(const Bytes \n&\n key,\n\n   \nnbsp(14)\nconst Bytes \n&\n old_value,\n\n   \nnbsp(14)\nconst Bytes \n&\n new_value)\n\n   \nReplaces each value in the list associated with key which is equal to old_value by new_value. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \ntemplate\n\n    \nvoid\n\n  \n\n  \n\n   \ntypename Procedure\n\n   \nforEachKey(Procedure process) const\n\n   \nApplies process to each key whose list is not empty. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \ntemplate\n\n    \nvoid\n\n  \n\n  \n\n   \ntypename Procedure\n\n   \nforEachValue(const Bytes \n&\n key, Procedure process) const\n\n   \nApplies process to each value associated with key. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \ntemplate\n\n    \nvoid\n\n  \n\n  \n\n   \ntypename BinaryProcedure\n\n   \nforEachEntry(BinaryProcedure process) const\n\n   \nApplies process to each key-iterator pair. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \nsize_t\n\n  \n\n  \n\n   \ngetNumPartitions() const\n\n   \nReturns the number of partitions. This value could be different from that specified in options when creating the map due to the fact that the next prime number has been taken.\n\n  \n\n \n\n \n\n \n\n  \n\n    \nstd::vector\nStats\n\n  \n\n  \n\n   \ngetStats() const\n\n   \nReturns statistical information about each partition of the map. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \nStats\n\n  \n\n  \n\n   \ngetTotalStats() const\n\n   \nReturns statistical information about the map. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \nbool\n\n  \n\n  \n\n   \nisReadOnly() const\n\n   \nReturns true if the map is read-only, false otherwise.\n\n  \n\n \n\n \n\n  \nStatic member functions\n\n \n\n \n\n  \n\n    \nstd::vector\nStats\n\n  \n\n  \n\n   \nstats(const boost::filesystem::path \n&\n directory)\n\n   \nReturns statistical information about each partition of the map located in directory. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \nvoid\n\n  \n\n  \n\n   \nimportFromBase64(const boost::filesystem::path \n&\n directory,\n\n   \nnbsp(17)\nconst boost::filesystem::path \n&\n input)\n\n   \nImports key-value pairs from an input file or directory into the map located in directory. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \nvoid\n\n  \n\n  \n\n   \nimportFromBase64(const boost::filesystem::path \n&\n directory,\n\n   \nnbsp(17)\nconst boost::filesystem::path \n&\n input)\n\n   \nnbsp(17)\nconst Options \n&\n options)\n\n   \nSame as before, but gives the user more control by providing an \nOptions\n parameter which is passed to the constructor of Map when opening. This way a map can be created if it does not already exist. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \nvoid\n\n  \n\n  \n\n   \nexportToBase64(const boost::filesystem::path \n&\n directory,\n\n   \nnbsp(15)\nconst boost::filesystem::path \n&\n output)\n\n   \nExports all key-value pairs from the map located in directory to a file denoted by output. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \nvoid\n\n  \n\n  \n\n   \nexportToBase64(const boost::filesystem::path \n&\n directory,\n\n   \nnbsp(15)\nconst boost::filesystem::path \n&\n output,\n\n   \nnbsp(15)\nconst Options \n&\n options)\n\n   \nSame as before, but gives the user more control by providing an \nOptions\n parameter. Most users will use this to pass a compare function that triggers a sorting of all lists before exporting them.\n\n  \n\n \n\n \n\n  \n\n    \nvoid\n\n  \n\n  \n\n   \noptimize(const boost::filesystem::path \n&\n directory,\n\n   \nnbsp(9)\nconst boost::filesystem::path \n&\n output)\n\n   \nRewrites the map located in directory to the directory denoted by output performing various optimizations. \nmore...\n\n  \n\n \n\n \n\n  \n\n    \nvoid\n\n  \n\n  \n\n   \noptimize(const boost::filesystem::path \n&\n directory,\n\n   \nnbsp(9)\nconst boost::filesystem::path \n&\n output,\n\n   \nnbsp(9)\nconst Options \n&\n options)\n\n   \nSame as before, but gives the user more control by providing an \nOptions\n parameter. Most users will use this to pass a compare function that triggers a sorting of all lists.\n\n  \n\n \n\n\n\n\n\n\n\n\n \nexplicit Map::Map(const boost::filesystem::path \n&\n directory)\n\n \nOpens an already existing map located in directory.\n\n \na \ndirectory lock\n on directory.\n\n \nstd::runtime_error\n if one of the following is true:\n\n \n\n  \nthe directory does not exist\n\n  \nthe directory cannot be locked\n\n  \nthe directory does not contain a map\n\n \n\n\n\n\n\n\n \n\n  \nMap::Map(const boost::filesystem::path \n&\n directory,\n\n  \nnbsp(9)\nconst Options \n&\n options)\n\n \n\n \nOpens or creates a map in directory. For the latter, you need to set \noptions.create_if_missing = true\n. If an error should be raised in case the map already exists, set \noptions.error_if_exists = true\n. When a new map is created other fields in options are used to configure the map's block size and number of partitions. See \nOptions\n for more information.\n\n \na \ndirectory lock\n on directory.\n\n \nstd::runtime_error\n if one of the following is true:\n\n \n\n  \nthe directory does not exist\n\n  \nthe directory cannot be locked\n\n \n\n \nwhen \noptions.create_if_missing = false\n (which is the default)\n\n \n\n  \nthe directory does not contain a map\n\n \n\n \nwhen \noptions.create_if_missing = true\n and no map exists\n\n \n\n  \noptions.block_size\n is zero\n\n  \noptions.block_size\n is not a power of two\n\n  \noptions.buffer_size\n is not a multiple of the block size\n\n \n\n \nwhen \noptions.error_if_exists = true\n\n \n\n  \nthe directory already contains a map\n\n \n\n\n\n\n\n\n \nvoid Map::put(const Bytes \n&\n key, const Bytes \n&\n value)\n\n \nAppends value to the end of the list associated with key.\n\n \n\n \n\n  \na \nwriter lock\n on the map object.\n\n  \na \nwriter lock\n on the list associated with key.\n\n \n\n \nstd::runtime_error\n if one of the following is true:\n\n \n\n  \nkey.size() > Map::Limits::maxKeySize()\n\n  \nvalue.size() > Map::Limits::maxValueSize()\n\n  \nthe map was opened in read-only mode\n\n \n\n\n\n\n\n\n \nMap::Iterator Map::get(const Bytes \n&\n key) const\n\n \nReturns a read-only iterator for the list associated with key. If the key does not exist, an empty iterator that has no values is returned. A non-empty iterator owns a lock on the associated list that is released automatically when the lifetime of the iterator ends. Note that objects of class \nMap::Iterator\n are moveable.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nreader lock\n on the list associated with key.\n\n \n\n\n\n\n\n\n \nbool Map::removeKey(const Bytes \n&\n key)\n\n \nRemoves all values associated with key.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nwriter lock\n on the list associated with key.\n\n \n\n \ntrue if any values have been removed, false otherwise.\n\n\n\n\n\n\n \n\n  \ntemplate \ntypename Predicate\n\n  \nuint32_t Map::removeKeys(Predicate predicate)\n\n \n\n \nRemoves all values associated with keys for which predicate yields true. The predicate can be any callable that implements the \nPredicate\n interface.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nwriter lock\n on lists associated with matching keys.\n\n \n\n \nthe number of keys for which any values have been removed.\n\n\n\n\n\n\n \n\n  \ntemplate \ntypename Predicate\n\n  \nbool Map::removeValue(const Bytes \n&\n key, Predicate predicate)\n\n \n\n \nRemoves the first value from the list associated with key for which predicate yields true. The predicate can be any callable that implements the \nPredicate\n interface.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nwriter lock\n on the list associated with key.\n\n \n\n \ntrue if any value has been removed, false otherwise.\n\n\n\n\n\n\n \n\n  \ntemplate \ntypename Predicate\n\n  \nuint32_t Map::removeValues(const Bytes \n&\n key, Predicate predicate)\n\n \n\n \nRemoves all values from the list associated with key for which predicate yields true. The predicate can be any callable that implements the \nPredicate\n interface.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nwriter lock\n on the list associated with key.\n\n \n\n \nthe number of values removed.\n\n\n\n\n\n\n \n\n  \ntemplate \ntypename Function\n\n  \nbool Map::replaceValue(const Bytes \n&\n key, Function map)\n\n \n\n \nReplaces the first value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced. The map function can be any callable that implements the \nFunction\n interface.\n\n \nNote that a replace operation is actually implemented in terms of a remove of the old value followed by an insert/put of the new value. Thus, the new value is always the last value in the list. In other words, the replacement is not in-place.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nwriter lock\n on the list associated with key.\n\n \n\n \ntrue if any value has been replaced, false otherwise.\n\n\n\n\n\n\n \n\n  \ntemplate \ntypename Function\n\n  \nuint32_t Map::replaceValues(const Bytes \n&\n key, Function map)\n\n \n\n \nReplaces each value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced. The map function can be any callable that implements the \nFunction\n interface.\n\n \nNote that a replace operation is actually implemented in terms of a remove of the old value followed by an insert/put of the new value. Thus, the new value is always the last value in the list. In other words, the replacement is not in-place.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nwriter lock\n on the list associated with key.\n\n \n\n \nthe number of values replaced.\n\n\n\n\n\n\n \n\n  \nuint32_t Map::replaceValues(const Bytes \n&\n key, \n\n  \nnbsp(28)\nconst Bytes \n&\n old_value,\n\n  \nnbsp(28)\nconst Bytes \n&\n new_value)\n\n \n\n \nReplaces each value in the list associated with key which is equal to old_value by new_value.\n\n \nNote that a replace operation is actually implemented in terms of a remove of the old value followed by an insert/put of the new value. Thus, the new value is always the last value in the list. In other words, the replacement is not in-place.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nwriter lock\n on the list associated with key.\n\n \n\n \nthe number of values replaced.\n\n\n\n\n\n\n \n\n  \ntemplate \ntypename Procedure\n\n  \nvoid Map::forEachKey(Procedure process) const\n\n \n\n \nApplies process to each key whose list is not empty. The process argument can be any callable that implements the \nProcedure\n interface. \n\n \na \nreader lock\n on the map object.\n\n\n\n\n\n\n \n\n  \ntemplate \ntypename Procedure\n\n  \nvoid Map::forEachValue(const Bytes \n&\n key, Procedure process) const\n\n \n\n \nApplies process to each value associated with key. The process argument can be any callable that implements the \nProcedure\n interface. \n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nreader lock\n on the list associated with key.\n\n \n\n\n\n\n\n\n \n\n  \ntemplate \ntypename BinaryProcedure\n\n  \nvoid Map::forEachEntry(BinaryProcedure process) const\n\n \n\n \nApplies process to each key-iterator pair. The process argument can be any callable that implements the \nBinaryProcedure\n interface. \n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nreader lock\n on the list that is currently processed.\n\n \n\n\n\n\n\n\n \n\n  \nstd::vector\nMap::Stats\n Map::getStats() const\n\n \n\n \nReturns statistical information about each partition of the map. This operation requires a traversal of the entire map visiting each entry.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nreader lock\n on the list that is currently visited.\n\n \n\n\n\n\n\n\n \n\n  \nMap::Stats\n Map::getTotalStats() const\n\n \n\n \nReturns statistical information about the map. In fact, this method computes the total values from the result returned by calling the previous method.\n\n \n\n \n\n  \na \nreader lock\n on the map object.\n\n  \na \nreader lock\n on the list that is currently visited.\n\n \n\n\n\n\n\n\n \n\n  \nstatic std::vector\nMap::Stats\n Map::stats(\n\n  \nnbsp(8)\nconst boost::filesystem::path \n&\n directory)\n\n \n\n \nReturns statistical information about each partition of the map located in directory. This method is similar to \nMap::getStats()\n except that the map does not need to be instanciated.\n\n \na \ndirectory lock\n on directory.\n\n\n\n\n\n\n \n\n  \nstatic void Map::importFromBase64(\n\n  \nnbsp(8)\nconst boost::filesystem::path \n&\n directory,\n\n  \nnbsp(8)\nconst boost::filesystem::path \n&\n input)\n\n \n\n \nImports key-value pairs from an input file or directory into the map located in directory. If input refers to a directory all files in that directory will be imported, except hidden files starting with a dot and other sub-directories. A description of the file format can be found in the \noverview\n section.\n\n \na \ndirectory lock\n on directory.\n\n \n everything thrown by the constructor of class \nMap\n or \nstd::runtime_error\n if the input file or directory cannot be read.\n\n\n\n\n\n\n \n\n  \nstatic void Map::exportToBase64(\n\n  \nnbsp(8)\nconst boost::filesystem::path \n&\n directory,\n\n  \nnbsp(8)\nconst boost::filesystem::path \n&\n output)\n\n \n\n \nExports all key-value pairs from the map located in directory to a file denoted by output. If the file already exists, its content will be overwritten. The generated file is in canonical form as described in the \noverview\n section.\n\n \na \ndirectory lock\n on directory.\n\n \nstd::runtime_error\n if one of the following is true:\n\n \n\n  \nthe directory does not exist\n\n  \nthe directory cannot be locked\n\n  \nthe directory does not contain a map\n\n  \nthe creation of the output file failed\n\n \n\n\n\n\n\n\n \n\n  \nstatic void Map::optimize(\n\n  \nnbsp(8)\nconst boost::filesystem::path \n&\n directory,\n\n  \nnbsp(8)\nconst boost::filesystem::path \n&\n output)\n\n \n\n \nRewrites the map located in directory to the directory denoted by output performing various optimizations. For more details please refer to the \noverview\n section.\n\n \na \ndirectory lock\n on directory.\n\n \nstd::runtime_error\n if one of the following is true:\n\n \n\n  \nthe directory does not exist\n\n  \nthe directory cannot be locked\n\n  \nthe directory does not contain a map\n\n  \nthe creation of a new map in output failed\n\n \n\n\n\n\n\ntype Map::Iterator\n\n\nThis type represents an iterator to read a list of values, possibly by streaming them from an external device.\n\n\nThe iterator supports lazy initialization, which means that no I/O operation is performed until a value is actually requested. This might be useful in cases where multiple iterators have to be collected first to determine in which order they have to be processed.\n\n\nThe iterator also owns a reader lock for the underlying list for synchronization purposes. This lock is automatically released when the iterator's destructor is called.\n\n\n\n\n\n \n\n  \nMember functions\n\n \n\n \n\n  \nuint32_t\n\n  \n\n   \navailable() const\n\n   \nReturns the remaining number of values to be iterated. Calling this method does not trigger any I/O operation.\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \nhasNext() const\n\n   \nReturns true if the iterator has more values, false otherwise.\n\n  \n\n \n\n \n\n  \nBytes\n\n  \n\n   \nnext()\n\n   \nReturns the next value from the underlying list and moves the iterator once forward. \nmore...\n\n  \n\n \n\n \n\n  \nBytes\n\n  \n\n   \npeekNext()\n\n   \nSame as before, but does not move the iterator once forward.\n\n  \n\n \n\n\n\n\n\n\n\n\n \n\n  \nBytes\n Map::Iterator::next()\n\n \n\n \nReturns the next value from the underlying list and moves the iterator once forward. The returned \nBytes\n object points to data managed by the iterator and is only valid for read access until the next call of this method. Reading from invalid data is undefined behavior. A deep copy of the value can be created by either calling its \ntoString()\n method or \nstd::memcpy()\n its data into another buffer.\n\n \nhasNext()\n yields true.\n\n\n\n\n\ntype Map::Limits\n\n\nThis type represents a namespace that provides static methods for obtaining system limitations. Those limits which define constraints on user supplied data also serve as preconditions.\n\n\n\n\n\n \n\n  \nStatic member functions\n\n \n\n \n\n  \nuint32_t\n\n  \n\n   \nmaxKeySize()\n\n   \nReturns the maximum size in number of bytes for a key to put.\n\n  \n\n \n\n \n\n  \nuint32_t\n\n  \n\n   \nmaxValueSize()\n\n   \nReturns the maximum size in number of bytes for a value to put.\n\n  \n\n \n\n\n\n\n\n\n\ntype Map::Stats\n\n\nThis type is a pure data holder for reporting statistical information.\n\n\n\n\n\n \n\n  \nData members\n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nblock_size\n\n   \nTells the block size of the map or partition which was defined in \nOptions\n when creating the map.\n\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nkey_size_avg\n\n   \nTells the average size in number of bytes of all keys in a map or partition. Note that keys that are currently not associated with any value are not taken into account.\n\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nkey_size_max\n\n   \nTells the size in number of bytes of the largest key in a map or partition.\n\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nkey_size_min\n\n   \nTells the size in number of bytes of the smallest key in a map or partition.\n\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nlist_size_avg\n\n   \nTells the average number of values associated with a key in a map or partition. Note that keys that are currently not associated with any value are not taken into account.\n\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nlist_size_max\n\n   \nTells the largest number of values associated with a key in a map or partition.\n\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nlist_size_min\n\n   \nTells the smallest number of values associated with a key in a map or partition. Note that keys that are currently not associated with any value are not taken into account.\n\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nnum_blocks\n\n   \nTells the number of blocks currently written to disk. Note that in-memory write buffer blocks that are associated with each keys are not taken into account. For more details please refer to the \noverview\n section.\n\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nnum_keys_total\n\n   \nTells the total number of keys in a map or partition, including keys that are currently not associated with any value.\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nnum_keys_valid\n\n   \nTells the number of valid keys in a map or partition. A valid key is associated with at least one value.\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nnum_values_total\n\n   \nTells the total number of values in a map or partition, including values that are marked as removed. Note that this number can only be decreased by running an \noptimize\n operation.\n  \n\n \n\n \n\n  \nuint64_t\n\n  \n\n   \nnum_values_valid\n\n   \nTells the number of values in a map or partition that are not marked as removed.\n\n  \n\n \n\n\n\n\n\n\n\nOptions.hpp\n\n\n#include \nmultimap/Options.hpp\n\nnamespace multimap\n\n\n\n\nclass Options\n\n\nThis class is a pure data holder used for configuration purposes.\n\n\n\n\n\n \n\n  \nData members\n\n \n\n \n\n  \nuint32_t\n\n  \n\n   \nblock_size\n\n   \nDefines the block size in number of bytes for a newly created map or partition. The value must be a power of two. Typical block sizes are 128, 256, 512 (default), 1024, or even larger. Please refer to the \noverview\n section for more details.\n\n  \n\n \n\n \n\n  \nuint32_t\n\n  \n\n   \nnum_partitions\n\n   \nDefines the number of partitions for a newly created map. The purpose of partitioning is to increase the performance of the \nexport\n and \noptimize\n operations by applying a divide and conquer method. A suitable number can be estimated like this: \"total number of value-bytes to be put\" divided by \"the memory allowed to be used running the operation\". An underestimate can lead to long runtimes for the mentioned operations. The default value is 23; other values will be rounded to the next prime number that is greater or equal to the given value.\n\n  \n\n \n\n \n\n  \nuint32_t\n\n  \n\n   \nbuffer_size\n\n   \nDefines the size of an internal buffer that contains blocks to be written. The default value is 1 MiB; other values are required to be a multiple of the given block size. Most users should leave this parameter alone.\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \ncreate_if_missing\n\n   \nIf set to true, creates a new map if it does not exist. The default value is false.\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \nerror_if_exists\n\n   \nIf set to true, throws an exception if a map already exists. The default value is false.\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \nreadonly\n\n   \nIf set to true, opens a map in read-only mode. In this mode all operations that could possibly modify the stored data are not allowed and will throw an exception on an attempt to do so. This flag is useful to prevent unintentional updates of read-only datasets. The default value is false.\n\n  \n\n \n\n \n\n  \nbool\n\n  \n\n   \nquiet\n\n   \nIf set to true, no status information for long running operations are sent to stdout. This flag is useful for writing shell scripts. The default value is false.\n\n  \n\n \n\n \n\n  \nCompare\n\n  \n\n   \ncompare\n\n   \nA callable that implements the \nCompare\n interface. It is used to sort lists of values when running certain operations such as \nexport\n or \noptimize\n. Actually this member is a \nfunction wrapper\n, not a generic type, which can be left empty (default) if no sorting is desired.\n\n  \n\n \n\n \n\n  \nMember functions\n\n \n\n \n\n  \nvoid\n\n  \n\n   \nkeepNumPartitions()\n\n   \nSets \nnum_partitions\n to a special value that indicates to the \noptimize\n operation that the number of partitions should not be changed. \n\n  \n\n \n\n \n\n  \nvoid\n\n  \n\n   \nkeepBlockSize()\n\n   \nSets \nblock_size\n to a special value that indicates to the \noptimize\n operation that the block size should not be changed.\n\n  \n\n \n\n\n\n\n\n\n\nInterfaces\n\n\nThe interfaces described here are requirements expected by some user-provided function objects. They are typically employed as template parameters and are not to be confused with abstract classes used in object-oriented programming. Sometimes this type of interfaces is also referred to as \nConcepts\n.\n\n\nCompare\n\n\nA callable that is applied to two instances of class \nBytes\n returning a boolean that tells if the left operand is less than the right operand. This interface is equivalent to the Compare concept described \nhere\n. Objects implementing this interface are typically used by sorting algorithms.\n\n\n\n\n\n \n\n  \nRequired member function\n\n \n\n \n\n  \nbool\n\n  \n\n   \noperator()(const Bytes \n&\n lhs, const Bytes \n&\n rhs) const\n\n   \nReturns true if lhs is considered less than rhs, false otherwise.\n\n  \n\n \n\n\n\n\n\n\n\nFunction\n\n\nA callable that is applied to an instance of class \nBytes\n returning a standard string. The returned string serves as a managed byte buffer and may contain arbitrary data. Objects implementing this interface are typically used for mapping input values to output values in replace operations.\n\n\n\n\n\n \n\n  \nRequired member function\n\n \n\n \n\n  \nstd::string\n\n  \n\n   \noperator()(const Bytes \n&\n bytes) const\n\n   \nMaps the given byte array to another byte array returned as standard string.\n\n  \n\n \n\n\n\n\n\n\n\nPredicate\n\n\nA callable that is applied to an instance of class \nBytes\n returning a boolean value. Objects implementing this interface are typically used to qualify keys or values for some further operation.\n\n\n\n\n\n \n\n  \nRequired member function\n\n \n\n \n\n  \nbool\n\n  \n\n   \noperator()(const Bytes \n&\n bytes) const\n\n   \nReturns a boolean value after evaluating the given byte array.\n\n  \n\n \n\n\n\n\n\n\n\nProcedure\n\n\nA callable that is applied to an instance of class \nBytes\n without returning any value. Procedures can have state that may change during application. Objects implementing this interface are typically used to visit keys or values, e.g. to collect information about them.\n\n\n\n\n\n \n\n  \nRequired member function\n\n \n\n \n\n  \nvoid\n\n  \n\n   \noperator()(const Bytes \n&\n bytes)\n\n   \nProcesses the given byte array, possibly changing the callable's state.\n\n  \n\n \n\n\n\n\n\n\n\nBinaryProcedure\n\n\nA callable that is applied to a pair of objects without returning a value. The first object being an instance of class \nBytes\n and the second object being an instance of class \nMap::Iterator\n. Binary procedures can have state that may change during application. Objects implementing this interface are typically used to visit entries when traversing a map.\n\n\n\n\n\n \n\n  \nRequired member function\n\n \n\n \n\n  \nvoid\n\n  \n\n   \noperator()(const Bytes \n&\n key, Map::Iterator iterator)\n\n   \nProcesses a list iterator that is associated with key, possibly changing the callable's state. Note that as long as the iterator is alive, the corresponding list is locked by a \nreader lock\n.\n\n  \n\n \n\n\n\n\n\n\n\nLocking\n\n\nMultimap makes use of three kinds of locks in order to synchronize concurrent access to objects of type \nMap\n.\n\n\nDirectory Lock\n\n\nA directory lock is a simple file located in the directory where a map lives. Such a file is created when a \nMap\n object is instantiated or any of its static member functions is called. When the object gets destructed or the function terminates the file is automatically deleted. The directory lock ensures that only one process can access a map at the same time.\n\n\nReader Lock\n\n\nA reader lock, also called shared lock, locks an object for read-only access. Multimap uses such locks to protect lists of values that are currently in use against modification by other threads. However, a single list can be read-locked by multiple threads at the same time.\n\n\nA reader lock is typically wrapped and owned by an iterator returned from calling \nMap::get()\n. According to \nRAII\n the lock is automatically released when the iterator gets destructed. Any method of \nMap\n that needs to acquire a reader lock to perform its operation will block if the resource is currently locked by a writer lock and until this lock is released.\n\n\nWriter Lock\n\n\nA writer lock, also called exclusive or unique lock, locks an object for read-write access. Multimap uses such locks to gain exclusive access to lists of values for modification purposes. When a list is locked by a writer lock it cannot be locked by any other reader or writer lock at the same time.\n\n\nUnlike reader locks that are wrapped by iterators, the ownership of writer locks is never transferred to the client in order to reduce the risk of running into deadlocks. Nevertheless, iterators that allow the modification of the underlying list are used inside the library. So, any method of \nMap\n that needs to acquire a writer lock to perform its operation will block if the resource is currently locked either by a reader lock or writer lock, and until this lock is released.", 
            "title": "C++ Reference"
        }, 
        {
            "location": "/cppreference/#byteshpp", 
            "text": "#include  multimap/Bytes.hpp \nnamespace multimap", 
            "title": "Bytes.hpp"
        }, 
        {
            "location": "/cppreference/#class-bytes", 
            "text": "This class is a thin wrapper for raw binary data. It just holds a pointer to data together with its size (number of bytes). It is used to represent keys and values that are put into or gotten from a map. An object of this class never deep copies the data it is constructed from, nor does it take any ownership of the data. It is really just a helper for providing a generic interface.   \n  \n   Member functions \n  \n  \n   \n   \n    Bytes() \n    Creates an empty byte array.  more... \n   \n  \n  \n   \n   \n    Bytes(const char * cstr) \n    Creates a byte array from a null-terminated C-string.  more... \n   \n  \n  \n   \n   \n    Bytes(const std::string  &  str) \n    Creates a byte array from a standard string.  more... \n   \n  \n  \n   \n   \n    Bytes(const void * data, size_t size) \n    Creates a byte array from arbitrary data.  more... \n   \n  \n  \n   const char * \n   \n    data() const \n    Returns a read-only pointer to the wrapped data. \n   \n  \n  \n   size_t \n   \n    size() const \n    Returns the number of bytes wrapped. \n   \n  \n  \n   const char * \n   \n    begin() const \n    Returns a read-only pointer to the beginning of the wrapped data. \n   \n  \n  \n   const char * \n   \n    end() const \n    Returns a past-the-end pointer to the wrapped data. \n   \n  \n  \n   bool \n   \n    empty() const \n    Tells whether the byte array is empty.  more... \n   \n  \n  \n   void \n   \n    clear() \n    Let this byte array point to an empty array.  more... \n   \n  \n  \n   std::string \n   \n    toString() const \n    Returns a string which contains a copy of the wrapped data.  more... \n   \n  \n  \n   Non-member functions \n  \n  \n   bool \n   \n    operator==(const Bytes  &  lhs, const Bytes  &  rhs) \n    Compares two byte arrays for equality.  more... \n   \n  \n  \n   bool \n   \n    operator!=(const Bytes  &  lhs, const Bytes  &  rhs) \n    Returns the inverse of the previous function. \n   \n  \n  \n   Helper classes \n  \n  \n   \n   \n    std::hash Bytes \n    Hash support for class Bytes.", 
            "title": "class Bytes"
        }, 
        {
            "location": "/cppreference/#callableshpp", 
            "text": "#include  multimap/callables.hpp \nnamespace multimap  This file contains some convenient function objects implementing the  Predicate  interface.", 
            "title": "callables.hpp"
        }, 
        {
            "location": "/cppreference/#struct-contains", 
            "text": "A function object that checks if a byte array contains another one in terms of a substring. Note that the empty byte array is a substring of any other byte array.   \n  \n   Member functions \n  \n  \n   explicit \n   \n    Contains(const Bytes  &  bytes) \n    Creates a functor that checks for containment of bytes when called. \n   \n  \n  \n   const Bytes  & \n   \n    bytes() const \n    Returns a read-only reference to the wrapped byte array. \n   \n  \n  \n   bool \n   \n    operator()(const Bytes  &  bytes) const \n    Returns true if bytes contains the wrapped byte array, false otherwise.", 
            "title": "struct Contains"
        }, 
        {
            "location": "/cppreference/#struct-startswith", 
            "text": "A function object that checks if a byte array has a certain prefix.   \n  \n   Member functions \n  \n  \n   explicit \n   \n    StartsWith(const Bytes  &  bytes) \n    Creates a functor that checks if a byte array starts with bytes when called. \n   \n  \n  \n   const Bytes  & \n   \n    bytes() const \n    Returns a read-only reference to the wrapped byte array. \n   \n  \n  \n   bool \n   \n    operator()(const Bytes  &  bytes) const \n    Returns true if bytes starts with the wrapped byte array, false otherwise.", 
            "title": "struct StartsWith"
        }, 
        {
            "location": "/cppreference/#struct-endswith", 
            "text": "A function object that checks if a byte array has a certain suffix.   \n  \n   Member functions \n  \n  \n   explicit \n   \n    EndsWith(const Bytes  &  bytes) \n    Creates a functor that checks if a byte array ends with bytes when called. \n   \n  \n  \n   const Bytes  & \n   \n    bytes() const \n    Returns a read-only reference to the wrapped byte array. \n   \n  \n  \n   bool \n   \n    operator()(const Bytes  &  bytes) const \n    Returns true if bytes ends with the wrapped byte array, false otherwise.", 
            "title": "struct EndsWith"
        }, 
        {
            "location": "/cppreference/#maphpp", 
            "text": "#include  multimap/Map.hpp \nnamespace multimap", 
            "title": "Map.hpp"
        }, 
        {
            "location": "/cppreference/#class-map", 
            "text": "This class implements a 1:n key-value store where each key is associated with a list of values. When putting a key-value pair into the map, the value is appended to the end of the list that is associated with the key. If no such key-list pair already exist, it will be created. Looking up a key returns a read-only iterator for the associated list. If the key does not exist, the list is considered to be empty and the returned iterator has no values to deliver. From a user's point of view there is no distinction between an empty list and a non-existing list.  Map also supports removing or replacing values. When a value is removed, it will be marked as such for the moment making it invisible for subsequent iterations. Running an  optimze  operation removes the data physically. The replace operation is implemented as a remove of the old value followed by an insert/put of the new value. In other words, the replacement is not in-place, but the new value is always the last value in the corresponding list. To restore a certain order an  optimze  operation can be run as well. However, optimization is considered a less frequent, more administrative task.  The class is designed to be a fast and mutable 1:n key-value store. For that reason, Map holds the entire key set in memory. This is also true for keys that were removed from the map at runtime. In addition, each key is associated with a write buffer which altogether contribute a lot to the total memory footprint of the map. Therefore, the number of keys to be put is limited by the amount of available memory. However, this simple design was intended in favour of performance, especially due to the fact that memory is relatively cheap and (server) machines are equipped with more and more of it. As a rule of thumb, assuming keys with 10 bytes in size on average, Map scales up to 10 M keys on desktop machines with 8 GiB of RAM and up to 100 M keys on server machines with 64 GiB of RAM. The number of values, though, is practically limited only by the amount of disk space. For more information, please visit the  overview  page.   \n  \n   Member types \n  \n  \n   \n   \n    Limits \n    Provides static methods to ask for maximum key and value sizes.  more... \n   \n  \n  \n   \n   \n    Stats \n    Type that reports statistical information about an instance of Map.  more... \n   \n  \n  \n   \n   \n    Iterator \n    Input iterator type that reads a list of values.  more... \n   \n  \n  \n   Member functions \n  \n  \n   explicit \n   \n    Map(const boost::filesystem::path  &  directory) \n    Opens an already existing map located in directory.  more... \n   \n  \n  \n   \n   \n    Map(const boost::filesystem::path  &  directory, \n    nbsp(4) const Options  &  options) \n    Opens or creates a map in directory.  more... \n   \n  \n  \n   \n   \n    ~Map() \n    Flushes all buffered data to disk, closes the map, and unlocks the directory where the map is located. \n   \n  \n  \n   void \n   \n    put(const Bytes  &  key, const Bytes  &  value) \n    Appends value to the end of the list associated with key.  more... \n   \n  \n  \n   Iterator \n   \n    get(const Bytes  &  key) const \n    Returns a read-only iterator for the list associated with key.  more... \n   \n  \n  \n   bool \n   \n    removeKey(const Bytes  &  key) \n    Removes all values associated with key.  more... \n   \n  \n  \n   \n     template \n     uint32_t \n   \n   \n    typename Predicate \n    removeKeys(Predicate predicate) \n    Removes all values associated with keys for which predicate yields true.  more... \n   \n  \n  \n   \n     template \n     bool \n   \n   \n    typename Predicate \n    removeValue(const Bytes  &  key, Predicate predicate) \n    Removes the first value from the list associated with key for which predicate yields true.  more... \n   \n  \n  \n   \n     template \n     uint32_t \n   \n   \n    typename Predicate \n    removeValues(const Bytes  &  key, Predicate predicate) \n    Removes all values from the list associated with key for which predicate yields true.  more... \n   \n  \n  \n   \n     template \n     bool \n   \n   \n    typename Function \n    replaceValue(const Bytes  &  key, Function map) \n    Replaces the first value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced.  more... \n   \n  \n  \n   \n     template \n     uint32_t \n   \n   \n    typename Function \n    replaceValues(const Bytes  &  key, Function map) \n    Replaces each value in the list associated with key by the result of invoking map. Values for which map returns the empty string are not replaced.  more... \n   \n  \n  \n   uint32_t \n   \n    replaceValues(const Bytes  &  key, \n    nbsp(14) const Bytes  &  old_value, \n    nbsp(14) const Bytes  &  new_value) \n    Replaces each value in the list associated with key which is equal to old_value by new_value.  more... \n   \n  \n  \n   \n     template \n     void \n   \n   \n    typename Procedure \n    forEachKey(Procedure process) const \n    Applies process to each key whose list is not empty.  more... \n   \n  \n  \n   \n     template \n     void \n   \n   \n    typename Procedure \n    forEachValue(const Bytes  &  key, Procedure process) const \n    Applies process to each value associated with key.  more... \n   \n  \n  \n   \n     template \n     void \n   \n   \n    typename BinaryProcedure \n    forEachEntry(BinaryProcedure process) const \n    Applies process to each key-iterator pair.  more... \n   \n  \n  \n   \n     size_t \n   \n   \n    getNumPartitions() const \n    Returns the number of partitions. This value could be different from that specified in options when creating the map due to the fact that the next prime number has been taken. \n   \n  \n  \n  \n   \n     std::vector Stats \n   \n   \n    getStats() const \n    Returns statistical information about each partition of the map.  more... \n   \n  \n  \n   \n     Stats \n   \n   \n    getTotalStats() const \n    Returns statistical information about the map.  more... \n   \n  \n  \n   \n     bool \n   \n   \n    isReadOnly() const \n    Returns true if the map is read-only, false otherwise. \n   \n  \n  \n   Static member functions \n  \n  \n   \n     std::vector Stats \n   \n   \n    stats(const boost::filesystem::path  &  directory) \n    Returns statistical information about each partition of the map located in directory.  more... \n   \n  \n  \n   \n     void \n   \n   \n    importFromBase64(const boost::filesystem::path  &  directory, \n    nbsp(17) const boost::filesystem::path  &  input) \n    Imports key-value pairs from an input file or directory into the map located in directory.  more... \n   \n  \n  \n   \n     void \n   \n   \n    importFromBase64(const boost::filesystem::path  &  directory, \n    nbsp(17) const boost::filesystem::path  &  input) \n    nbsp(17) const Options  &  options) \n    Same as before, but gives the user more control by providing an  Options  parameter which is passed to the constructor of Map when opening. This way a map can be created if it does not already exist.  more... \n   \n  \n  \n   \n     void \n   \n   \n    exportToBase64(const boost::filesystem::path  &  directory, \n    nbsp(15) const boost::filesystem::path  &  output) \n    Exports all key-value pairs from the map located in directory to a file denoted by output.  more... \n   \n  \n  \n   \n     void \n   \n   \n    exportToBase64(const boost::filesystem::path  &  directory, \n    nbsp(15) const boost::filesystem::path  &  output, \n    nbsp(15) const Options  &  options) \n    Same as before, but gives the user more control by providing an  Options  parameter. Most users will use this to pass a compare function that triggers a sorting of all lists before exporting them. \n   \n  \n  \n   \n     void \n   \n   \n    optimize(const boost::filesystem::path  &  directory, \n    nbsp(9) const boost::filesystem::path  &  output) \n    Rewrites the map located in directory to the directory denoted by output performing various optimizations.  more... \n   \n  \n  \n   \n     void \n   \n   \n    optimize(const boost::filesystem::path  &  directory, \n    nbsp(9) const boost::filesystem::path  &  output, \n    nbsp(9) const Options  &  options) \n    Same as before, but gives the user more control by providing an  Options  parameter. Most users will use this to pass a compare function that triggers a sorting of all lists.", 
            "title": "class Map"
        }, 
        {
            "location": "/cppreference/#type-mapiterator", 
            "text": "This type represents an iterator to read a list of values, possibly by streaming them from an external device.  The iterator supports lazy initialization, which means that no I/O operation is performed until a value is actually requested. This might be useful in cases where multiple iterators have to be collected first to determine in which order they have to be processed.  The iterator also owns a reader lock for the underlying list for synchronization purposes. This lock is automatically released when the iterator's destructor is called.   \n  \n   Member functions \n  \n  \n   uint32_t \n   \n    available() const \n    Returns the remaining number of values to be iterated. Calling this method does not trigger any I/O operation. \n   \n  \n  \n   bool \n   \n    hasNext() const \n    Returns true if the iterator has more values, false otherwise. \n   \n  \n  \n   Bytes \n   \n    next() \n    Returns the next value from the underlying list and moves the iterator once forward.  more... \n   \n  \n  \n   Bytes \n   \n    peekNext() \n    Same as before, but does not move the iterator once forward.", 
            "title": "type Map::Iterator"
        }, 
        {
            "location": "/cppreference/#type-maplimits", 
            "text": "This type represents a namespace that provides static methods for obtaining system limitations. Those limits which define constraints on user supplied data also serve as preconditions.   \n  \n   Static member functions \n  \n  \n   uint32_t \n   \n    maxKeySize() \n    Returns the maximum size in number of bytes for a key to put. \n   \n  \n  \n   uint32_t \n   \n    maxValueSize() \n    Returns the maximum size in number of bytes for a value to put.", 
            "title": "type Map::Limits"
        }, 
        {
            "location": "/cppreference/#type-mapstats", 
            "text": "This type is a pure data holder for reporting statistical information.   \n  \n   Data members \n  \n  \n   uint64_t \n   \n    block_size \n    Tells the block size of the map or partition which was defined in  Options  when creating the map. \n   \n  \n  \n   uint64_t \n   \n    key_size_avg \n    Tells the average size in number of bytes of all keys in a map or partition. Note that keys that are currently not associated with any value are not taken into account. \n   \n  \n  \n   uint64_t \n   \n    key_size_max \n    Tells the size in number of bytes of the largest key in a map or partition. \n   \n  \n  \n   uint64_t \n   \n    key_size_min \n    Tells the size in number of bytes of the smallest key in a map or partition. \n   \n  \n  \n   uint64_t \n   \n    list_size_avg \n    Tells the average number of values associated with a key in a map or partition. Note that keys that are currently not associated with any value are not taken into account. \n   \n  \n  \n   uint64_t \n   \n    list_size_max \n    Tells the largest number of values associated with a key in a map or partition. \n   \n  \n  \n   uint64_t \n   \n    list_size_min \n    Tells the smallest number of values associated with a key in a map or partition. Note that keys that are currently not associated with any value are not taken into account. \n   \n  \n  \n   uint64_t \n   \n    num_blocks \n    Tells the number of blocks currently written to disk. Note that in-memory write buffer blocks that are associated with each keys are not taken into account. For more details please refer to the  overview  section. \n   \n  \n  \n   uint64_t \n   \n    num_keys_total \n    Tells the total number of keys in a map or partition, including keys that are currently not associated with any value.\n   \n  \n  \n   uint64_t \n   \n    num_keys_valid \n    Tells the number of valid keys in a map or partition. A valid key is associated with at least one value.\n   \n  \n  \n   uint64_t \n   \n    num_values_total \n    Tells the total number of values in a map or partition, including values that are marked as removed. Note that this number can only be decreased by running an  optimize  operation.\n   \n  \n  \n   uint64_t \n   \n    num_values_valid \n    Tells the number of values in a map or partition that are not marked as removed.", 
            "title": "type Map::Stats"
        }, 
        {
            "location": "/cppreference/#optionshpp", 
            "text": "#include  multimap/Options.hpp \nnamespace multimap", 
            "title": "Options.hpp"
        }, 
        {
            "location": "/cppreference/#class-options", 
            "text": "This class is a pure data holder used for configuration purposes.   \n  \n   Data members \n  \n  \n   uint32_t \n   \n    block_size \n    Defines the block size in number of bytes for a newly created map or partition. The value must be a power of two. Typical block sizes are 128, 256, 512 (default), 1024, or even larger. Please refer to the  overview  section for more details. \n   \n  \n  \n   uint32_t \n   \n    num_partitions \n    Defines the number of partitions for a newly created map. The purpose of partitioning is to increase the performance of the  export  and  optimize  operations by applying a divide and conquer method. A suitable number can be estimated like this: \"total number of value-bytes to be put\" divided by \"the memory allowed to be used running the operation\". An underestimate can lead to long runtimes for the mentioned operations. The default value is 23; other values will be rounded to the next prime number that is greater or equal to the given value. \n   \n  \n  \n   uint32_t \n   \n    buffer_size \n    Defines the size of an internal buffer that contains blocks to be written. The default value is 1 MiB; other values are required to be a multiple of the given block size. Most users should leave this parameter alone. \n   \n  \n  \n   bool \n   \n    create_if_missing \n    If set to true, creates a new map if it does not exist. The default value is false. \n   \n  \n  \n   bool \n   \n    error_if_exists \n    If set to true, throws an exception if a map already exists. The default value is false. \n   \n  \n  \n   bool \n   \n    readonly \n    If set to true, opens a map in read-only mode. In this mode all operations that could possibly modify the stored data are not allowed and will throw an exception on an attempt to do so. This flag is useful to prevent unintentional updates of read-only datasets. The default value is false. \n   \n  \n  \n   bool \n   \n    quiet \n    If set to true, no status information for long running operations are sent to stdout. This flag is useful for writing shell scripts. The default value is false. \n   \n  \n  \n   Compare \n   \n    compare \n    A callable that implements the  Compare  interface. It is used to sort lists of values when running certain operations such as  export  or  optimize . Actually this member is a  function wrapper , not a generic type, which can be left empty (default) if no sorting is desired. \n   \n  \n  \n   Member functions \n  \n  \n   void \n   \n    keepNumPartitions() \n    Sets  num_partitions  to a special value that indicates to the  optimize  operation that the number of partitions should not be changed.  \n   \n  \n  \n   void \n   \n    keepBlockSize() \n    Sets  block_size  to a special value that indicates to the  optimize  operation that the block size should not be changed.", 
            "title": "class Options"
        }, 
        {
            "location": "/cppreference/#interfaces", 
            "text": "The interfaces described here are requirements expected by some user-provided function objects. They are typically employed as template parameters and are not to be confused with abstract classes used in object-oriented programming. Sometimes this type of interfaces is also referred to as  Concepts .", 
            "title": "Interfaces"
        }, 
        {
            "location": "/cppreference/#compare", 
            "text": "A callable that is applied to two instances of class  Bytes  returning a boolean that tells if the left operand is less than the right operand. This interface is equivalent to the Compare concept described  here . Objects implementing this interface are typically used by sorting algorithms.   \n  \n   Required member function \n  \n  \n   bool \n   \n    operator()(const Bytes  &  lhs, const Bytes  &  rhs) const \n    Returns true if lhs is considered less than rhs, false otherwise.", 
            "title": "Compare"
        }, 
        {
            "location": "/cppreference/#function", 
            "text": "A callable that is applied to an instance of class  Bytes  returning a standard string. The returned string serves as a managed byte buffer and may contain arbitrary data. Objects implementing this interface are typically used for mapping input values to output values in replace operations.   \n  \n   Required member function \n  \n  \n   std::string \n   \n    operator()(const Bytes  &  bytes) const \n    Maps the given byte array to another byte array returned as standard string.", 
            "title": "Function"
        }, 
        {
            "location": "/cppreference/#predicate", 
            "text": "A callable that is applied to an instance of class  Bytes  returning a boolean value. Objects implementing this interface are typically used to qualify keys or values for some further operation.   \n  \n   Required member function \n  \n  \n   bool \n   \n    operator()(const Bytes  &  bytes) const \n    Returns a boolean value after evaluating the given byte array.", 
            "title": "Predicate"
        }, 
        {
            "location": "/cppreference/#procedure", 
            "text": "A callable that is applied to an instance of class  Bytes  without returning any value. Procedures can have state that may change during application. Objects implementing this interface are typically used to visit keys or values, e.g. to collect information about them.   \n  \n   Required member function \n  \n  \n   void \n   \n    operator()(const Bytes  &  bytes) \n    Processes the given byte array, possibly changing the callable's state.", 
            "title": "Procedure"
        }, 
        {
            "location": "/cppreference/#binaryprocedure", 
            "text": "A callable that is applied to a pair of objects without returning a value. The first object being an instance of class  Bytes  and the second object being an instance of class  Map::Iterator . Binary procedures can have state that may change during application. Objects implementing this interface are typically used to visit entries when traversing a map.   \n  \n   Required member function \n  \n  \n   void \n   \n    operator()(const Bytes  &  key, Map::Iterator iterator) \n    Processes a list iterator that is associated with key, possibly changing the callable's state. Note that as long as the iterator is alive, the corresponding list is locked by a  reader lock .", 
            "title": "BinaryProcedure"
        }, 
        {
            "location": "/cppreference/#locking", 
            "text": "Multimap makes use of three kinds of locks in order to synchronize concurrent access to objects of type  Map .", 
            "title": "Locking"
        }, 
        {
            "location": "/cppreference/#directory-lock", 
            "text": "A directory lock is a simple file located in the directory where a map lives. Such a file is created when a  Map  object is instantiated or any of its static member functions is called. When the object gets destructed or the function terminates the file is automatically deleted. The directory lock ensures that only one process can access a map at the same time.", 
            "title": "Directory Lock"
        }, 
        {
            "location": "/cppreference/#reader-lock", 
            "text": "A reader lock, also called shared lock, locks an object for read-only access. Multimap uses such locks to protect lists of values that are currently in use against modification by other threads. However, a single list can be read-locked by multiple threads at the same time.  A reader lock is typically wrapped and owned by an iterator returned from calling  Map::get() . According to  RAII  the lock is automatically released when the iterator gets destructed. Any method of  Map  that needs to acquire a reader lock to perform its operation will block if the resource is currently locked by a writer lock and until this lock is released.", 
            "title": "Reader Lock"
        }, 
        {
            "location": "/cppreference/#writer-lock", 
            "text": "A writer lock, also called exclusive or unique lock, locks an object for read-write access. Multimap uses such locks to gain exclusive access to lists of values for modification purposes. When a list is locked by a writer lock it cannot be locked by any other reader or writer lock at the same time.  Unlike reader locks that are wrapped by iterators, the ownership of writer locks is never transferred to the client in order to reduce the risk of running into deadlocks. Nevertheless, iterators that allow the modification of the underlying list are used inside the library. So, any method of  Map  that needs to acquire a writer lock to perform its operation will block if the resource is currently locked either by a reader lock or writer lock, and until this lock is released.", 
            "title": "Writer Lock"
        }, 
        {
            "location": "/javareference/", 
            "text": "", 
            "title": "Java Reference"
        }, 
        {
            "location": "/cppinstallation/", 
            "text": "For C++ Developers\n\n\nMultimap is implemented in standard C++11 and POSIX. Its target platform is GNU/Linux.\n\n\nGet the Source Code\n\n\nDownload the latest release tarball from GitHub: \nhttps://github.com/mtrenkmann/multimap/releases\n\n\ncd path/to/download\ntar xzvf multimap-\nversion\n.tar.gz\ncd multimap-\nversion\n\n\n\n\n\nor clone the repository to your local machine:\n\n\ngit clone https://github.com/mtrenkmann/multimap.git\ncd multimap\ngit checkout tags/\ntagname\n\n\n# where \ntagname\n should be the latest release.\n# Use `git tag -l` to list all available tags.\n\n\n\n\nInstall Build Tools\n\n\nMultimap uses \nqmake\n as its Makefile generator.\n\n\nsudo apt-get install qt5-make\n# For Debian 8 based distros\n\nsudo apt-get install qt4-make\n# For Debian 7 based distros\n\n# Don't know your Debian release?\n# lsb_release -r\n\nsudo apt-get install make g++ \n\n\n\n\nInstall Dependencies\n\n\nsudo apt-get install libboost-filesystem-dev libboost-system-dev libboost-thread-dev\n\n\n\n\nInstall Shared Library\n\n\nqmake multimap-library.pro\n\n# if you encounter an error, try\nqmake -qt=5 multimap-library.pro\n# or\nqmake -qt=4 multimap-library.pro\n\nmake\nsudo make install\nsudo ldconfig\n\n\n\n\nThis installs the shared library \nlibmultimap.so\n in \n/usr/local/lib\n and the header files in \n/usr/local/include/multimap\n. Note that some distributions do not search \n/usr/local/lib\n by default when looking for library dependencies. In this case you need to add \n/usr/local/lib\n to \n/etc/ld.so.conf\n. If you are not allowed to do so, you can also set \nLD_LIBRARY_PATH=/usr/local/lib\n before running your application. For more information see \nldconfig\n and/or \nman ldconfig\n.\n\n\nInstall Command Line Tool\n\n\nqmake multimap-tool.pro\n\n# if you encounter an error, try\nqmake -qt=5 multimap-tool.pro\n# or\nqmake -qt=4 multimap-tool.pro\n\nmake\nsudo make install\n\n\n\n\nThis builds and installs the executable \nmultimap\n in \n/usr/local/bin\n. If this directory is not listed in your \nPATH\n variable, you can add it by putting \nPATH=\"/usr/local/bin:$PATH\"\n either into \n~/.profile\n or \n~/.bashrc\n.", 
            "title": "for C++ Developers"
        }, 
        {
            "location": "/cppinstallation/#for-c-developers", 
            "text": "Multimap is implemented in standard C++11 and POSIX. Its target platform is GNU/Linux.", 
            "title": "For C++ Developers"
        }, 
        {
            "location": "/cppinstallation/#get-the-source-code", 
            "text": "Download the latest release tarball from GitHub:  https://github.com/mtrenkmann/multimap/releases  cd path/to/download\ntar xzvf multimap- version .tar.gz\ncd multimap- version   or clone the repository to your local machine:  git clone https://github.com/mtrenkmann/multimap.git\ncd multimap\ngit checkout tags/ tagname \n\n# where  tagname  should be the latest release.\n# Use `git tag -l` to list all available tags.", 
            "title": "Get the Source Code"
        }, 
        {
            "location": "/cppinstallation/#install-build-tools", 
            "text": "Multimap uses  qmake  as its Makefile generator.  sudo apt-get install qt5-make\n# For Debian 8 based distros\n\nsudo apt-get install qt4-make\n# For Debian 7 based distros\n\n# Don't know your Debian release?\n# lsb_release -r\n\nsudo apt-get install make g++", 
            "title": "Install Build Tools"
        }, 
        {
            "location": "/cppinstallation/#install-dependencies", 
            "text": "sudo apt-get install libboost-filesystem-dev libboost-system-dev libboost-thread-dev", 
            "title": "Install Dependencies"
        }, 
        {
            "location": "/cppinstallation/#install-shared-library", 
            "text": "qmake multimap-library.pro\n\n# if you encounter an error, try\nqmake -qt=5 multimap-library.pro\n# or\nqmake -qt=4 multimap-library.pro\n\nmake\nsudo make install\nsudo ldconfig  This installs the shared library  libmultimap.so  in  /usr/local/lib  and the header files in  /usr/local/include/multimap . Note that some distributions do not search  /usr/local/lib  by default when looking for library dependencies. In this case you need to add  /usr/local/lib  to  /etc/ld.so.conf . If you are not allowed to do so, you can also set  LD_LIBRARY_PATH=/usr/local/lib  before running your application. For more information see  ldconfig  and/or  man ldconfig .", 
            "title": "Install Shared Library"
        }, 
        {
            "location": "/cppinstallation/#install-command-line-tool", 
            "text": "qmake multimap-tool.pro\n\n# if you encounter an error, try\nqmake -qt=5 multimap-tool.pro\n# or\nqmake -qt=4 multimap-tool.pro\n\nmake\nsudo make install  This builds and installs the executable  multimap  in  /usr/local/bin . If this directory is not listed in your  PATH  variable, you can add it by putting  PATH=\"/usr/local/bin:$PATH\"  either into  ~/.profile  or  ~/.bashrc .", 
            "title": "Install Command Line Tool"
        }, 
        {
            "location": "/javainstallation/", 
            "text": "For Java Developers\n\n\nMultimap comes with a language binding for Java based on JNI. Although it's Java, the target platform of the native library is still GNU/Linux.\n\n\nThe following steps will build\n\n\n\n\na shared library with JNI support,\n\n\na JAR file to be added to your project's classpath\n\n\n\n\nGet the Source Code\n\n\nDownload the latest release tarball from GitHub: \nhttps://github.com/mtrenkmann/multimap/releases\n\n\ncd path/to/download\ntar xzvf multimap-\nversion\n.tar.gz\ncd multimap-\nversion\n\n\n\n\n\nor clone the repository to your local machine:\n\n\ngit clone https://github.com/mtrenkmann/multimap.git\ncd multimap\ngit checkout tags/\ntagname\n\n\n# where \ntagname\n should be the latest release.\n# Use `git tag -l` to list all available tags.\n\n\n\n\nInstall Build Tools\n\n\nMultimap uses \nqmake\n as its Makefile generator.\n\n\nsudo apt-get install qt5-make\n# For Debian 8 based distros\n\nsudo apt-get install qt4-make\n# For Debian 7 based distros\n\n# Don't know your Debian release?\n# lsb_release -r\n\nsudo apt-get install make g++\n\n\n\n\nInstall Dependencies\n\n\nsudo apt-get install libboost-filesystem-dev libboost-system-dev libboost-thread-dev\n\n\n\n\nDefine JAVA_HOME\n\n\nIn order to build the native library with JNI support, some header files from a Java Development Kit (JDK) are needed. If not yet available, install a JDK and define the \nJAVA_HOME\n environment variable pointing to it.\n\n\nsudo apt-get install openjdk-7-jdk\n\nexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64\n# For Debian 8 based distros (x86-64)\n\nexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-i386\n# For Debian 8 based distros (x86-32)\n\n\n\n\nBuild JNI Shared Library\n\n\nqmake multimap-library-jni.pro\n\n# if you encounter an error, try\nqmake -qt=5 multimap-library-jni.pro\n# or\nqmake -qt=4 multimap-library-jni.pro\n\nmake\n\n\n\n\nThis builds the shared library \nlibmultimap-jni.so\n. \n\n\nInstall JNI Shared Library\n\n\nsudo make install\nsudo ldconfig\n\n\n\n\nThis installs the shared library in \n/usr/local/lib\n. Since the Java VM does not search this directory by default when trying to load native libraries, you additionally need to set the \njava.library.path\n variable pointing to that location. Simply add\n\n\n-Djava.library.path=/usr/local/lib\n\n\n\n\nto the VM arguments of your Java project. Of course, you can let the variable pointing to any directory, even your download folder, if you won't or are not allowed to install the library system-wide.\n\n\n-Djava.library.path=/home/user/downloads/multimap-\nversion\n\n\n\n\n\nBuild Java Library\n\n\n./make-multimap-jar.sh\n\n\n\n\nThis builds the JAR file \nmultimap-\nversion\n.jar\n that you can add to your project's classpath.", 
            "title": "for Java Developers"
        }, 
        {
            "location": "/javainstallation/#for-java-developers", 
            "text": "Multimap comes with a language binding for Java based on JNI. Although it's Java, the target platform of the native library is still GNU/Linux.  The following steps will build   a shared library with JNI support,  a JAR file to be added to your project's classpath", 
            "title": "For Java Developers"
        }, 
        {
            "location": "/javainstallation/#get-the-source-code", 
            "text": "Download the latest release tarball from GitHub:  https://github.com/mtrenkmann/multimap/releases  cd path/to/download\ntar xzvf multimap- version .tar.gz\ncd multimap- version   or clone the repository to your local machine:  git clone https://github.com/mtrenkmann/multimap.git\ncd multimap\ngit checkout tags/ tagname \n\n# where  tagname  should be the latest release.\n# Use `git tag -l` to list all available tags.", 
            "title": "Get the Source Code"
        }, 
        {
            "location": "/javainstallation/#install-build-tools", 
            "text": "Multimap uses  qmake  as its Makefile generator.  sudo apt-get install qt5-make\n# For Debian 8 based distros\n\nsudo apt-get install qt4-make\n# For Debian 7 based distros\n\n# Don't know your Debian release?\n# lsb_release -r\n\nsudo apt-get install make g++", 
            "title": "Install Build Tools"
        }, 
        {
            "location": "/javainstallation/#install-dependencies", 
            "text": "sudo apt-get install libboost-filesystem-dev libboost-system-dev libboost-thread-dev", 
            "title": "Install Dependencies"
        }, 
        {
            "location": "/javainstallation/#define-java_home", 
            "text": "In order to build the native library with JNI support, some header files from a Java Development Kit (JDK) are needed. If not yet available, install a JDK and define the  JAVA_HOME  environment variable pointing to it.  sudo apt-get install openjdk-7-jdk\n\nexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64\n# For Debian 8 based distros (x86-64)\n\nexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-i386\n# For Debian 8 based distros (x86-32)", 
            "title": "Define JAVA_HOME"
        }, 
        {
            "location": "/javainstallation/#build-jni-shared-library", 
            "text": "qmake multimap-library-jni.pro\n\n# if you encounter an error, try\nqmake -qt=5 multimap-library-jni.pro\n# or\nqmake -qt=4 multimap-library-jni.pro\n\nmake  This builds the shared library  libmultimap-jni.so .", 
            "title": "Build JNI Shared Library"
        }, 
        {
            "location": "/javainstallation/#install-jni-shared-library", 
            "text": "sudo make install\nsudo ldconfig  This installs the shared library in  /usr/local/lib . Since the Java VM does not search this directory by default when trying to load native libraries, you additionally need to set the  java.library.path  variable pointing to that location. Simply add  -Djava.library.path=/usr/local/lib  to the VM arguments of your Java project. Of course, you can let the variable pointing to any directory, even your download folder, if you won't or are not allowed to install the library system-wide.  -Djava.library.path=/home/user/downloads/multimap- version", 
            "title": "Install JNI Shared Library"
        }, 
        {
            "location": "/javainstallation/#build-java-library", 
            "text": "./make-multimap-jar.sh  This builds the JAR file  multimap- version .jar  that you can add to your project's classpath.", 
            "title": "Build Java Library"
        }
    ]
}